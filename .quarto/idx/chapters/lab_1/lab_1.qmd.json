{"title":"Radiology Clinic","markdown":{"headingText":"Radiology Clinic","containsRefs":false,"markdown":"\nIn this lab you will be introduced to the basics of creating a simulation model using the discrete event simulation software Jaamsim and the HCCM module.\nTo do this we will use the CT service of a radiology clinic as an example.\nAt the clinic patients: arrive according to a known distribution 24/7; check in at reception, which takes a uniformly distributed amount of time; and then have a scan, the duration of which also follows a known distribution; and finally leave. \n\nWe want to use the simulation to determine the average time that patients spend in the clinic, between arriving and leaving.\nWe want to compare this time to the time that patients would spend in the system if interarrival times and scan durations were always equal to the average of the distributions for all patients.\nTypically we would first formulate the simulation model by defining the objectives, benefits, conceptual model, and experiments.\nFor the sake of brevity we will only cover the experiments.\nAs the aim of the lab is to learn the basics of Jaamsim, the conceptual model is not given here, instead it is available in [@sec-radiology_cm].\n\n## Experiments\n\nWe will perform just one experiment, using distributions for the arrival, check in, and scan processes.\nWe will use a Poisson distribution with $\\lambda=8/\\text{hour}$ for the arrival process, a uniform distribution between 2 and 5 minutes for the check in durations, and a log-normal distribution where the underlying normal variable has a mean of -1.34 and standard deviation 0.29 for the scan durations.\nFor the experiment we will run 50 replications that each last for 1 week.\n\n## Jaamsim Model\n\n### Creating Model Objects\n\nRun Jaamsim by opening Eclipse and the clicking the run button and select GUIFrame.\nThe HCCM palette on the left hand side allows us to create Jaamsim objects that correspond to the components of our HCCM conceptual models.\nBased on the problem description and conceptual model we need three types of entities: patients, receptionists, and CT Machines.\nTo create each of these expand the HCCM palette in the Model Builder window, select ActiveEntity, and dragging it into the View Window, see [@fig-ent_pic].\nThen in the Object Selector window select ActiveEntity1, press F2, and rename it `PatientEntity`.\n\n::: {#fig-ent_pic .column-margin}\n![](figures/entity_creation.png){height=75mm}\n\nScreenshot of an ActiveEntity\n\n:::\n\nRepeat this process two more times and create ActiveEntities called `ReceptionistEntity` and `CTMachineEntity`.\n\nAn ActiveEntity object by itself does not create any entities in the simulation, it just acts as a prototype for entities.\nTo create entities an ArriveEvent object is used, which simulates patients/receptionists/CTMachines arriving at the clinic.\nThe ArriveEvent object creates a series of entities that are passed to the next object in a process.\nThe PrototypeEntity keyword identifies the entity to be copied.\nThe rate at which entities are generated is determined by the InterArrivalTime and FirstArrivalTime keywords.\nCreate three ArriveEvents called `PatientArrival`, `ReceptionistArrival`, and `CTMachineArrival`, and set the PrototypeEntity to be the related entity (patient, receptionist, CTMachine).\n\nWe also need to create objects that represent the entities leaving, called LeaveEvent, we will only create one for the patients, as we are assuming that the receptionist and CT machines are available 24/7 so they do not need to leave.\nDrag and drop a leave event into the simulation, rename it `PatientLeave`, and set the Participant to be the patient entity (under the HCCM tab).\n\nThe patients waiting for check in and scanning, and both the receptionist and CT machines waiting for tasks can be represented by WaitActivities, so create four WaitActivities and rename them `WaitForCheckIn`, `WaitForScan`, `WaitForTaskReceptionist`, and `WaitForTaskCTMachine` respectively, and once again set the Participant to the respective entity.\n\nWe can then represent the patient doing check in with the receptionist, and the patient being scanned by a CT machine as process activities.\nCreate two process activities and rename them `CheckIn`, and `Scan`.\n\nWe also need to create objects to represent the probability distributions that the interarrival, check in, and scan times come from.\nProbability distributions can be represented in Jaamsim with distribution objects.\nIf we examine the PatientArrival object we see two keywords FirstArrivalTime and InterArrivalTime which determine the rate that the entities are created.\nFor a Poisson process with an average of 8 arrivals per hour the interarrival times can be modelled by an exponential distribution with mean 0.125 hours.\nWe therefore go into the Probability Distributions palette in the Model Builder window and create an ExponentialDistribution object and name it `ArrivalDistribution`.\nFirst we set the UnitType keyword to be `TimeUnit`, then we set the mean of the distribution to `0.125 h`.\nThe UnitType tells Jaamsim what type of value we want the distribution object to create, in our case this is the time between arrivals in hours, which is a unit of time.\nAlso make sure that the `RandomSeed` is 1, this determines the seed for the random number generator.\n[@tbl-arr_dist] shows the keywords and values for the `ArrivalDistribution` object.\n\n::: {#tbl-arr_dist .sm}\n\n```{=latex}\n\\begin{tabular}{@{}lll@{}}\n\\toprule\nObject                & Keyword         & Value         \\\\ \\midrule\nArrivalDistribution   & UnitType        & TimeUnit      \\\\\n                      & RandomSeed      & 1             \\\\\n                      & Mean            & 0.125 h       \\\\ \\bottomrule\n\\end{tabular}\n```\n\nArrival Distribution Inputs\n\n:::\n\nWe need to repeat these steps for the check in and scan processes, which follow uniform and log-normal distributions respectively, so create a UniformDistribution object called `CheckInDistribution` and a `LogNormalDistribution` object called `ScanDistribution`.\nThen update the keywords of the distribution objects as follows in [@tbl-serv_dists]:\n\n::: {#tbl-serv_dists .sm}\n\n```{=latex}\n\\begin{tabular}{@{}lll@{}}\n\\toprule\nObject              & Keyword     & Value                       \\\\ \\midrule\nCheckInDistribtuion & UnitType    & TimeUnit                    \\\\\n                    & RandomSeed  & 2                           \\\\\n                    & MinValue    & 2 min                       \\\\\n                    & MaxValue    & 5 min                       \\\\\n & & \\\\\nScanDistribution    & UnitType    & TimeUnit                    \\\\\n                    & RandomSeed  & 3                           \\\\\n                    & Scale       & 1 h                         \\\\\n                    & NormalMean  & -1.34                       \\\\\n                    & NormalSD    & 0.29                        \\\\ \\bottomrule\n\\end{tabular}\n```\n\nCheck In and Scan Distributions\n\n:::\n\nThe final object we need at this stage is a Statistics object, to capture some output about the patients.\nThis is found under the ProcessFlow palette, create a Statistics object and call it `TimeInSystem`.\n\nAt this point you should have the objects shown in [@tbl-mod_objs] in your simulation.\n\n::: {#tbl-mod_objs .sm}\n\n```{=latex}\n\\begin{tabular}{@{}ll@{}}\n\\toprule\nObject Type     & Name             \\\\ \\midrule\nActiveEntity    & PatientEntity    \\\\\nActiveEntity    & ReceptionistEntity    \\\\\nActiveEntity    & CTMachineEntity  \\\\\n                &                  \\\\\nArriveEvent     & PatientArrival   \\\\\nArriveEvent     & ReceptionistArrival   \\\\\nArriveEvent     & CTMachineArrival \\\\\n                &                  \\\\\nLeaveEvent      & PatientLeave     \\\\\n                &                  \\\\\nWaitActivity    & WaitForCheckIn   \\\\\nWaitActivity    & WaitForScan      \\\\\nWaitActivity    & WaitForTaskReceptionist \\\\\nWaitActivity    & WaitForTaskCTMachine    \\\\\n                &                  \\\\\nProcessActivity & CheckIn          \\\\\nProcessActivity & Scan             \\\\\n                &                  \\\\\nExponentialDistribution & ArrivalDistribution             \\\\\nUniformDistribution & CheckInDistribution             \\\\\nLogNormalDistribution & ScanDistribution             \\\\\n                &                  \\\\\nStatistics      & TimeInSystem   \\\\ \\bottomrule\n\\end{tabular}\n```\n\nModel Objects\n\n:::\n\nOnce you have created all of these objects lay them out similarly to as shown in [@fig-sim_pic].\n\n::: {#fig-sim_pic .column-page-right}\n![](figures/Example_layout_2.png)\n\nScreenshot of Simulation Model Layout\n\n:::\n\nCreate a new folder in the 'labs' folder called 'RC1' and save your simulation as 'radiology\\_lab.cfg' or something similar inside the new folder. \nAlso take this opportunity to change the graphics of the PatientEntity, ReceptionistEntity and CTMachineEntity.\nDownload the patient.png, receptionist.png, and ctscanner.png (icons made by Freepik from www.flaticon.com) files from Canvas and save them in the same folder as your simulation .cfg file.\nThen in Jaamsim right click on PatientEntity and select Change Graphics.\nClick on Import and navigate to your downloaded patient.png, import it (it may be called patient-model) and accept the change.\nRepeat the process for the receptionists, and CT scanners.\n\n### Configuring Objects\n\nNow that we have created the objects we need, we need to set the options for the each of them, starting with the ArriveEvents.\nThe PatientArrival should have both the first arrival time and inter arrival times set by the ArrivalDistribution object, use the PatientEntity as a prototype, and the NextAEJObject should be WaitForCheckIn.\nNextAEJObject stands for next activity/event/Jaamsim object and refers to the fact that the next place an entity goes could be a standard Jaamsim object or a custom HCCM activity or event.\nFor the arrive events we set NextAEJObject to the object that represents the activity that is transitioned to at the end of the event state changes in the conceptual model.\nFor the ReceptionistArrival and CTMachineArrival we need to: set the prototype entity; both MaxNumber and InitialNumber (1 for receptionist, 3 for CT Machine); and set the NextAEJObject to the respective wait activity.\n\n::: {#tbl-arr_params .sm}\n\n```{=latex}\n\\begin{tabular}{@{}llll@{}}\n\\toprule\nObject              & Tab        & Keyword         & Value         \\\\ \\midrule\nPatientArrival      & Key Inputs & PrototypeEntity  & PatientEntity \\\\\nPatientArrival      & Key Inputs & FirstArrivalTime & ArrivalDistribution \\\\\nPatientArrival      & Key Inputs & InterArrivalTime & ArrivalDistribution \\\\\nPatientArrival      & HCCM       & NextAEJObject    & WaitForCheckIn \\\\\n                    &            &                  &                 \\\\\nReceptionistArrival & Key Inputs & PrototypeEntity  & ReceptionistEntity \\\\\nReceptionistArrival & Key Inputs & MaxNumber        & 1               \\\\\nReceptionistArrival & Key Inputs & InitialNumber        & 1               \\\\\nReceptionistArrival & HCCM       & NextAEJObject    & WaitForTaskReceptionist \\\\\n                    &            &                  &                 \\\\\nCTMachineArrival    & Key Inputs & PrototypeEntity  & CTMachineEntity \\\\\nCTMachineArrival    & Key Inputs & MaxNumber        & 3               \\\\\nCTMachineArrival    & Key Inputs & InitialNumber        & 3               \\\\\nCTMachineArrival    & HCCM       & NextAEJObject    & WaitForTaskCTMachine \\\\ \\bottomrule\n\\end{tabular}\n```\n\nArrival Event Parameters\n\n:::\n\nNext we will set the options for the Process Activities (and Statistics) so that the routing/flow for the entities is correct.\nThe Check In activity has both the Patient and Receptionist as participants so we set the Participant list to PatientEntity, ReceptionistEntity.\nThe duration is determined by the check in distribution, so we just set the duration to be CheckInDistribution object.\nAfter Check In the Patient starts waiting for a scan and the receptionist goes back to waiting for a task, so we set the NextAEJList to WaitForScan, WaitForTaskReceptionist.\nThe Scan activity has both the Patient and CTMachine as participants and the duration is determined by the ScanDistribution object.\nAfter Scan the Patient should just leave, but we want to record some statistics first so we send it to TimeInSystem, and the CTMachine goes back to WaitForTaskCTMachine.\nFor Process Activities the NextAEJList is similar to the NextAEJObject from the Arrive Events (which is similar to NextComponent), the difference is that a list of next objects is given, one for each of the participants in the activity.\nThe participants are sent to the corresponding element of the list so it is important that the next activities are in the same order as the participants.\n\nNote that when you click on the checkboxes in the popup menu for both ParticipantList and NextAEJList the items are added in alphabetical order, not the order you click them in.\nThis is particularly important for the Scan activity as the CTMachineEntity comes before the PatientEntity alphabetically, but for the next activities TimeInSystem is before WaitForTaskCTMachine alphabetically so the two lists will not be in the same order.\n\n::: {#tbl-pro_params .sm}\n\n```{=latex}\n\\begin{tabular}{@{}llll@{}}\n\\toprule\nObject              & Tab        & Keyword          & Value         \\\\ \\midrule\nCheckIn             & Key Inputs & Duration         & CheckInDistribution \\\\\nCheckIn             & HCCM       & ParticipantList  & PatientEntity ReceptionistEntity \\\\\nCheckIn             & HCCM       & NextAEJList      & WaitForScan WaitForTaskReceptionist   \\\\\n                    &            &                  &                 \\\\\nScan                & Key Inputs & Duration         & ScanDistribution \\\\\nScan                & HCCM       & ParticipantList  & PatientEntity CTMachineEntity \\\\\nScan                & HCCM       & NextAEJList      & TimeInSystem WaitForTaskCTMachine   \\\\\\bottomrule\n\\end{tabular}\n```\n\nProcess Activity Parameters\n\n:::\n\nThe last object we need to configure before the simulation will run (it will run but it will not quite work correctly) is the TimeInSystem object.\nThis is a Statistics object which collects a value from each Entity that passes through it and outputs the mean of the sampled values.\nWe then need to finish the routing so that patients leave after going through the TimeInSystem, and tell the Statistics object which value to record as shown in [@tbl-stats], note that `this` refers to the Statistics object itself, `obj` refers to the entity that the Statistics object is currently processing, and `TotalTime` is an output on the entity that stores the total time that the entity has been in the simulation for.\n\n::: {#tbl-stats .sm}\n\n```{=latex}\n\\begin{tabular}{@{}lll@{}}\n\\toprule\nObject        & Keyword        & Value \\\\ \\midrule\nTimeInSystem  & NextComponent  & PatientLeave  \\\\\n              & UnitType       & TimeUnit   \\\\ \n              & SampleValue    & this.obj.TotalTime  \\\\ \\bottomrule\n\\end{tabular}\n```\n\nCollecting Statistics\n\n:::\n\nSave your simulation again. \nIf you run your simulation now you should see one receptionist arrive and wait, three CT machines arrive and wait, and patients arrive, and wait for check in.\nHowever nothing else will happen and all of the entities will simply be waiting, this is because we have not specified any logic to be triggered when the entities start waiting.\n\n## Model Logic -- Java\n\nIn your eclipse project you should have a folder called 'sim\\_custom' under the Project Explorer on the left hand side in Eclipse.\nFirst right-click on this folder and select New $\\rightarrow$ Package.\nEnter `labs` for the name of the package and click Finish.\n\n::: {#fig-create_package_1 .column-margin}\n![](figures/create_new_package.png)\n\nFirst Step in Creating a New Package\n\n:::\n\n::: {#fig-create_package_2}\n![](figures/labs_package.png)\n\nSecond Step in Creating a New Package\n\n:::\n\nRight click on the newly created labs package and select New $\\rightarrow$ Class.\nName the Class `RadiologyControlUnit` and enter `hccm.controlunits.ControlUnit` for the Superclass.\n\n::: {#fig-create_class_1 .column-margin}\n![](figures/create_new_class.png)\n\nFirst Step in Creating a New Class\n\n:::\n\n::: {#fig-create_class_2}\n![](figures/control_unit_class_2.png)\n\nSecond Step in Creating a New Class\n\n:::\n\nWhat this has done is created a new Java class, based off the ControlUnit class, which we will use to implement the logic required for the clinic.\nThe final step required to make this new object available in the simulation is to add to the contents of the sim\\_custom.inc file that we put in sim $\\rightarrow$ hccm $\\rightarrow$ jaamsim $\\rightarrow$ src $\\rightarrow$ main $\\rightarrow$ resources $\\rightarrow$ resources $\\rightarrow$ inputs.\nThere should already be some code there from the previous lab, so you only need to add lines 3, 7, and 10.\nIf you want to copy and paste this make sure the quotes are copied correctly and the return (arrow) on line 10 is removed.\nAlternatively there is a new sim\\_custom.inc file on Canvas under Jaamsim Lab 1 that you can use directly.\n\n<!-- :::{.column-page-right} -->\n\n```{.default .code-overflow-scroll}\nDefine ObjectType {\n\tFIFOQControlUnit\n\tRadiologyControlUnit\n}\n\nControllerIconModel ImageFile { '<res>/images/Controller-256.png' }  Transparent { TRUE }\nAssembleIconModel ImageFile { '<res>/images/Assemble-256.png' }  Transparent { TRUE }\n\nFIFOQControlUnit JavaClass { ssq.FIFOQControlUnit }  Palette { 'Single Server Queue' } DefaultDisplayModel { ControllerIconModel } IconFile { '<res>/images/Controller-24.png' } DefaultSize { 0.5 0.5 0.5 m }\nRadiologyControlUnit JavaClass { labs.RadiologyControlUnit }  Palette { 'Custom Logic' } DefaultDisplayModel { AssembleIconModel } IconFile { '<res>/images/Assemble-24.png' } DefaultSize { 0.5 0.5 0.5 m }\n```\n\n<!-- ::: -->\n\nOnce you have updated the sim\\_custom.inc file, clean your project and restart Jaamsim.\nIf everything is working correctly the RadiologyControlUnit object should now be available under the Custom Logic palette as shown in the screenshot below:\n\n::: {#fig-cu_obj}\n![](figures/control_unit_jaamsim_2.png)\n\nScreenshot of Control Unit Object\n\n:::\n\nOnce you have the new RadiologyControlUnit object available open your simulation and create one.\n\nWe now need to add the Java code to the new RadiologyControlUnit class to run the control policies.\nFirst add the following imports under the package declaration. **Note** These code snippets for this lab are provided in a separate file for you\n\n```{.java}\npackage labs;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport hccm.activities.ProcessActivity;\nimport hccm.controlunits.ControlUnit;\nimport hccm.entities.ActiveEntity;\n```\n\nThen, within the definition of the class we need to create four methods that represent the four control policies in the model.\nEach control policy is a public method of the class that does not return any value (is void) and takes both a list of Active Entities, and the simulation time as inputs.\nWe will use the same names for the methods as the control policies in the conceptual model: `OnStartWaitForCheckIn`, `OnStartWaitForScan`, `OnStartWaitForTaskReceptionist`, and `OnStartWaitForTaskCTMachine`.\nIn the first of these, `OnStartWaitForCheckIn` we first need to get a list of the Receptionist Entities that are currently in the ''WaitForTaskReceptionist\" activity, and we also create a comparator object that is used to sort a list of entities by when they started their current activity.\n\nOnce we have the list of idle receptionists we check whether it is not empty, and if it isn't proceed to sort it, select the first one, and transition the patient and receptionist to the check in activity.\n\n:::{.column-page-right}\n\n```{.java}\npublic void OnStartWaitForCheckIn(List<ActiveEntity> ents, double simTime) {\n        \n    ArrayList<ActiveEntity> idleReceps = this.getEntitiesInActivity(\"ReceptionistEntity\", \"WaitForTaskReceptionist\", simTime);\n    ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n    if (idleReceps.size() > 0) {\n      Collections.sort(idleReceps, actSartComp);\n      \n      ActiveEntity patient = ents.get(0);\n      ActiveEntity receptionist = idleReceps.get(0);\n      \n      transitionTo(\"CheckIn\", patient, receptionist);\n    }\n  }\n```\n\n:::\n\nSimilar methods are defined for the other control policies, with small changes based on the types of entities that are being checked, and the activity that is started.\nThere are gaps that need to be filled in on lines 3, 24, and 42.\nIn the first gap you need to create an array that contains all of the CT Machines that are currently idle.\nIn the second, you need to select which of the patients that are currently waiting should do check in with the receptionist.\nIn the third, you need to start the next activity with the patient and CT Machine.\nAll of these have similar lines in the first method that you can use as a guide.\n\n:::{.column-page-right}\n\n```{.java}\npublic void OnStartWaitForScan(List<ActiveEntity> ents, double simTime) {\n  \n    // A //\n    ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n    if (idleCTs.size() > 0) {\n      Collections.sort(idleCTs, actSartComp);\n      \n      ActiveEntity patient = ents.get(0);\n      ActiveEntity ct = idleCTs.get(0);\n\n      transitionTo(\"Scan\", patient, ct);\n    }\n  }\n    \npublic void OnStartWaitForTaskReceptionist(List<ActiveEntity> ents, double simTime) {\n      \n  ArrayList<ActiveEntity> waitPats = this.getEntitiesInActivity(\"PatientEntity\", \"WaitForCheckIn\", simTime);\n  ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n  \n  if (waitPats.size() > 0) {\n    Collections.sort(waitPats, actSartComp);\n    \n    // B //\n    ActiveEntity receptionist = ents.get(0);\n\n    transitionTo(\"CheckIn\", patient, receptionist);\n  }\n}\n\npublic void OnStartWaitForTaskCTMachine(List<ActiveEntity> ents, double simTime) {\n  \n  ArrayList<ActiveEntity> waitPats = this.getEntitiesInActivity(\"PatientEntity\", \"WaitForScan\", simTime);\n  ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n  if (waitPats.size() > 0) {\n    Collections.sort(waitPats, actSartComp);\n    \n    ActiveEntity patient = waitPats.get(0);\n    ActiveEntity ct = ents.get(0);\n\n    // C //\n  }\n}\n```\n\n:::\n\nThe final step needed to get this logic into the simulation is to define Triggers that initiate these methods and where/when they should be called.\nTo do this create four Trigger objects, called `StartWaitCheckIn`, `StartWaitScan`, `StartWaitTaskReceptionist`, and `StartWaitTaskCTMachine` from the HCCM palette and set the ControlUnit and ControlPolicy for each one.\nThe value of the ControlPolicy keyword needs to exactly match the name of the method you have defined in the java code.\n\n:::{#tbl-trig_params .sm}\n```{=latex}\n\\begin{tabular}{@{}llll@{}}\n\\toprule\nObject                    & Tab  & Keyword       & Value         \\\\ \\midrule\nStartWaitCheckIn          & HCCM & ControlUnit   & RadiologyControlUnit1 \\\\\nStartWaitCheckIn          & HCCM & ControlPolicy & OnStartWaitForCheckIn \\\\\n                          &      &               &                 \\\\\nStartWaitScan             & HCCM & ControlUnit   & RadiologyControlUnit1 \\\\\nStartWaitScan             & HCCM & ControlPolicy & OnStartWaitForScan \\\\\n                          &      &               &                 \\\\\nStartWaitTaskReceptionist & HCCM & ControlUnit   & RadiologyControlUnit1 \\\\\nStartWaitTaskReceptionist & HCCM & ControlPolicy & OnStartWaitForTaskReceptionist \\\\\n                    &            &                  &                 \\\\\nStartWaitTaskCTMachine    & HCCM & ControlUnit   & RadiologyControlUnit1 \\\\\nStartWaitTaskCTMachine    & HCCM & ControlPolicy & OnStartWaitForTaskCTMachine \\\\\n\\bottomrule\n\\end{tabular}\n```\n\nTrigger Parameters\n\n:::\n\nThen update the parameters in the Wait Activities that these control policies should be triggered in:\n\n:::{#tbl-wait_params .sm}\n```{=latex}\n\\begin{tabular}{@{}llll@{}}\n\\toprule\nObject                  & Tab  & Keyword            & Value         \\\\ \\midrule\nWaitForCheckIn          & HCCM & StartTriggerList   & StartWaitCheckIn \\\\\nWaitForCheckIn          & HCCM & StartTriggerChoice & 1 \\\\\n                        &      &               &                 \\\\\nWaitForScan             & HCCM & StartTriggerList   & StartWaitScan \\\\\nWaitForScan             & HCCM & StartTriggerChoice & 1 \\\\\n                        &      &               &                 \\\\\nWaitForTaskReceptionist & HCCM & StartTriggerList   & StartWaitTaskReceptionist \\\\\nWaitForTaskReceptionist & HCCM & StartTriggerChoice & 1 \\\\\n                        &      &               &                 \\\\\nWaitForTaskCTMachine    & HCCM & StartTriggerList   & StartWaitTaskCTMachine \\\\\nWaitForTaskCTMachine    & HCCM & StartTriggerChoice & 1 \\\\\n\\bottomrule\n\\end{tabular}\n```\n\nWait Activity Parameters\n\n:::\n\nNow if you save and run your simulation you should be able to see patients arriving, checking in, being scanned, and leaving.\nIf you get an error saying that a method cannot be found on the control unit, first make sure that all of the ControlPolicy inputs exactly match the names of the methods in the control unit java file.\nThen try closing Jaamsim, cleaning your project, and restarting Jaamsim.\n\n## Model Output\n\nTo perform different experiments and multiple replications we make use of Jaamsim's MultipleRuns feature which can be found in the Simulation object at the top of the Object Selector window.\nHere we can use the `NumberOfReplications` to control how many replications are performed.\nWe want to do 50 replications so we set NumberOfReplications to 50.\nWe want each replication to run for one week, so we set RunDuration to `7d`.\nTo record outputs we can make use of the Simulation object's RunOutputList, which saves the final value of outputs at the end of each run.\nThe scenario number, and the replication number are saved by default (by default PrintRunLabels and PrintReplications are TRUE), but we will calculate confidence intervals ourselves so we set PrintConfidenceIntervals to FALSE.\nBecause ActiveEntities are removed from the simulation when they enter a LeaveEvent, we cannot get the total time that each patient spends in the clinic at the end of the run.\nThis is why we created a Statistics object called TimeInSystem that records how long they have been in the system before they are destroyed.\nWe can use the SampleAverage output of the TimeInSystem object in the Simulation's RunOutputList to output the mean time in system for each replication. **Note** The SampleAverage is divided by 1[h] to give a raw number in hours for later processing in R. Otherwise JaamSim writes an h to the data file.\n\n:::{#tbl-sim_params .sm}\n```{=latex}\n\\begin{tabular}{@{}llll@{}}\n\\toprule\nObject     & Tab           & Keyword             & Value            \\\\ \\midrule\nSimulation & Key Inputs    & RunDuration         & 7 d              \\\\\nSimulation & Key Inputs    & RunOutputList       & \\{`[TimeInSystem].SampleAverage / 1[h]'\\}\\\\\nSimulation & Multiple Runs & NumberOfReplications        & 50 \\\\\nSimulation & Multiple Runs & PrintConfidenceIntervals & FALSE\\\\\\bottomrule\n\\end{tabular}\n```\n\nSimulation Parameters\n\n:::\n\nNow if you save and run your simulation a file should be created called 'yourSimulationName.dat'.\nTo speed up running the simulation you can turn off the option 'Real time', in the top left corner next to the play button.\n\nWith the model complete and the results recorded we can use R to analyse them.\nFirst download the R analysis file provided, then change the working directory and name of the .dat and .log files to match yours, then run the R file.\nThe following table should be printed:\n\n:::{#tbl-sim_output .sm}\n```{=latex}\n\\begin{tabular}{lll}\n\\toprule\nlower95CI   & mean  & upper95CI \\\\\n0.442       & 0.449 & 0.457     \\\\ \\bottomrule                    \n\\end{tabular}\n```\n\nR Output\n\n:::\n\n## Task\n\nConstruct a 95\\% confidence interval for the average utilisation of the three CT machines in each experiment.\nYou should get the following output:\n\n:::{#tbl-task_output .sm}\n```{=latex}\n\\begin{tabular}{lll}\n\\toprule\nlower95CI   & mean  & upper95CI \\\\\n0.724       & 0.731 & 0.737     \\\\ \\bottomrule                    \n\\end{tabular}\n```\n\nTask Output\n\n:::\n\nHint: there are many ways to do this. Have a look at the outputs provided on the wait activity `WaitForTaskCTMachine`, can you calculate the total time that the three CTMachines have spent waiting using these outputs?\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"svg","to":"html","pdf-engine":"pdflatex","reference-location":"margin","filters":["parse-latex"],"syntax-definitions":["../../cm_pseudo.xml"],"highlight-style":"haddock","css":["../../styles.css"],"output-file":"lab_1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.554","bibliography":["../../references.bib"],"citation-location":"margin","callout-icon":false,"crossref":{"custom":[{"kind":"float","reference-prefix":"Control Policy","key":"cntrlplcy","latex-env":"cntrlplcy"}]},"theme":"lumen"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":"htbp","fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"pdflatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","reference-location":"margin","filters":["parse-latex"],"include-in-header":["../../preamble.tex"],"output-file":"lab_1.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["../../references.bib"],"citation-location":"margin","callout-icon":false,"crossref":{"custom":[{"kind":"float","reference-prefix":"Control Policy","key":"cntrlplcy","latex-env":"cntrlplcy"}]},"documentclass":"scrreprt","papersize":"a4paper","fontsize":"10pt","tbl-pos":"htbp","geometry":["top=10mm","left=17.5mm","right=82.5mm","marginparsep=10mm","marginparwidth=55mm"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}