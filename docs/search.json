[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ENGSCI 355 Labs",
    "section": "",
    "text": "Preface\nThese are an online version of the Labs for ENGSCI 355. The topics covered are: a hands-on simulation of a manufacturing process; conceptual modelling using HCCM; implementing HCCM models in Jaamsim; and missing data imputaton.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/hands_on_production/hands_on_production.html",
    "href": "chapters/hands_on_production/hands_on_production.html",
    "title": "1  Operations System in Practice",
    "section": "",
    "text": "1.1 Making Paper Cars\nThe system that we will use as an example is making a car out of paper. You will each be given a piece of paper with the net of paper car on it as in Figure 1.1.\nYou will also get a pair of scissors, some tape, and blank pieces of paper. To make the car:\nFigure 1.2 shows an example of a completed car.\nFirst everyone should make one car by themselves. Once you have, show one of the instructors to get signed off. Then, discuss with you group how you can work together to make paper cars. You might want to experiment with different setups/policies and try making a few cars to see how long it takes and gather some data.\nThere will be a competition to see which group can make the most cars in 10 minutes. Before the time starts each group must submit an estimate of how many cars they believe they will be able to make. The score for each group will then be comprised of the following elements:\nAdditionally, the following rules must be followed:",
    "crumbs": [
      "Practical Lab",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Operations System in Practice</span>"
    ]
  },
  {
    "objectID": "chapters/hands_on_production/hands_on_production.html#making-paper-cars",
    "href": "chapters/hands_on_production/hands_on_production.html#making-paper-cars",
    "title": "1  Operations System in Practice",
    "section": "",
    "text": "Figure 1.1: The Net Used to Make Paper Cars\n\n\n\n\nTrace the net onto a new piece of paper.\nCut the new net out.\nFold the paper and tape the edges shut placing the tabs on the inside.\n\n\n\n\n\n\n\n\n\nFigure 1.2: A Completed Car\n\n\n\n\n\n1 point for each car completed up to and including the estimated number.\n0.25 points for each car completed above the estimated number.\n-0.75 points for each car not completed in the estimated number.\n\n\n\nEach car must be traced and cut individually.\nCars must be the same shape as the original template, including tabs.\nYou can have as many stencils as you like.\nAll final cars must have started as a blank, unfolded piece of paper.\nYou may not have any pre-cut tape or nets.\nAll cars must have been made only by members of your group.\nAll cars must be folded and taped neatly to count. The lecturer has final say on whether a car meets the required neatness.",
    "crumbs": [
      "Practical Lab",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Operations System in Practice</span>"
    ]
  },
  {
    "objectID": "chapters/hands_on_production/hands_on_production.html#reflections",
    "href": "chapters/hands_on_production/hands_on_production.html#reflections",
    "title": "1  Operations System in Practice",
    "section": "1.2 Reflections",
    "text": "1.2 Reflections\nNow that you have attempted to make as many cars as you can you may wish to reflect on the process by asking yourself the following questions:\n\nDid your group have any traced/cut out cars left at the end?\nWhat was the bottleneck/slowest part of the system?\nDid you collect any data/do any experiments? If so, did they help? Would you do more/different ones now?\nWhat would you do differently next time?\n\nThe process that we considered was relatively simple. Cinsider how would your group’s strategy change if any of the following additional conditions were added:\n\nBlank pieces of paper for you to trace onto only become available one at a time every two minutes;\nYou have to make different styles of cars on demand;\nThere is a limit to how many traced nets/cut pieces of tape you can have at any point (buffer limit);\nEach time a pair of scissors is stopped being used there is a cooldown time of 1 minute.",
    "crumbs": [
      "Practical Lab",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Operations System in Practice</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html",
    "href": "chapters/hccm_framework/hccm_framework.html",
    "title": "2  HCCM Framework",
    "section": "",
    "text": "2.1 Understanding of the Problem Situation\nIn Phase 1, in order to understand the problem situation, you need to summarise what is happening in a concise way. There is no strict rule for the best way to do this. One good approach is listening to the problem “holder”, i.e., person/people who have the problem such as a client, then reflecting what you have heard in a couple of paragraphs with lists of key details and questions. You can then work through one or more iterations of feedback and refinement to get a final, agreed upon problem description.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html#identification-of-modelling-and-general-objectives",
    "href": "chapters/hccm_framework/hccm_framework.html#identification-of-modelling-and-general-objectives",
    "title": "2  HCCM Framework",
    "section": "2.2 Identification of Modelling and General Objectives",
    "text": "2.2 Identification of Modelling and General Objectives\nFor Phase 2, as described in lectures, there are two types of objectives to consider when developing a simulation:\n\n“The second step deals with the determination of the objectives. According to Robinson [26] they drive all aspects of the modeling process and are a subset of an organization’s aims. Further, objectives can be classified into modeling and general objectives, where the latter are concerned with the flexibility, run-speed, visual-display and model/component reuse.”\n\nFor the modelling objective you may like to think about what you trying to discover using simulation, and what level of performance you are trying to achieve in which areas/metrics.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html#defining-output-responses",
    "href": "chapters/hccm_framework/hccm_framework.html#defining-output-responses",
    "title": "2  HCCM Framework",
    "section": "2.3 Defining Output Responses",
    "text": "2.3 Defining Output Responses\nPhase 3 includes defining both the output responses and input factors. You can do these in either order, but it can often be useful to define the output responses first, as it may help you think about what inputs will influence the outputs.\nOutput responses are things that can be measured and compared to understand how a system has behaved/performed. They are the metrics used to compare different simulation scenarios. The output responses should let you know whether the modelling objectives have been achieved and why or how. You may also want to consider how this will be reported (tables, graphs, etc.).",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html#defining-input-factors",
    "href": "chapters/hccm_framework/hccm_framework.html#defining-input-factors",
    "title": "2  HCCM Framework",
    "section": "2.4 Defining Input Factors",
    "text": "2.4 Defining Input Factors\nInput factors are things that can be changed and may modify how a system behaves/performs. They are often defined to create multiple different scenarios to compare via simulation. They are also what you can change to try and achieve the modelling objectives.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html#model-content",
    "href": "chapters/hccm_framework/hccm_framework.html#model-content",
    "title": "2  HCCM Framework",
    "section": "2.5 Model Content",
    "text": "2.5 Model Content\nIn Phase 4 the model content is defined. There is no strict order in which you need to complete the four components (structre, behaviour, data, and logic). A possible approach, that we will take in this lab, is to:\n\nIdentify the entities;\nDraw the behavioural paths;\nDefine the data;\nDefine the structure (including the entities again);\nDefine the logic.\n\nUsing this approach you may still find yourself deciding to add/remove parts that you have already defined. This is a normal part of the conceptual modelling process, and you need to go back to the part of the process you want to change – for example adding and entity or activity – and then update the rest of the CM.\nFor the model content definition of our conceptual model we will follow the new HCCM standard. This standard is presented in an academic article (currently under review) that is available on Canvas under Files &gt; Lectures &gt; Conceptual Modelling in the file hccm-standard.pdf\n\n2.5.1 Identifying Entities\nBefore formally defining entities it is often useful to identify entities in the system and whether they are active, i.e., have behaviour like a doctor or patient, or passive, i.e., are part of the system that should be modelled but that don’t have explicit behaviour like a waiting room with a given capacity, but that doesn’t actually have defined actions.\nThe goal is to identify everything that is involved in a meaningful way in all of the activities that are important to the system. Thinking about the inputs and outputs can also be useful. Clearly the entities must be influenced in some way by the inputs, and they must themselves influence the outputs. You may also consider that an activity does not have a significant influence on the performance of the system, and decide to exclude it – and therefore any entities that are involved only in that activity. Likewise the participation of a particular entity in an activity might be deemed inconsequential and therefore excluded. Although it is possible to revisit and add/remove entities later, at this stage you want to consider the whole system carefully, as it is easier to include/exclude an entity now than to change it later.\n\n\n2.5.2 Drawing Behavioural Paths\nOnce preliminary identification of entities has been done, behavioural paths for each of the active entities should be drawn. These are essentially flowcharts with a special structure. Circles represent events, usually used when entities are arriving and leaving. Rectangles represent activities, including when entities have to wait for another activity. Red squares at the top left of an activity (or sometimes an event) let us know that some logic is triggered when the activity starts. This generally occurs at the start of “wait” activities and is used to check whether the conditions that mean the entity can stop waiting and move on to the next activity are met.\nWhat we are trying to do when drawing the behavioural paths is identify the activities and events that the entities participate in, the possible orders that these can occur in, and any points where some control logic needs to be used.\nBoth when identifying the entities and drawing the behavioural paths it is important to keep track of any assumptions and simplifications that you make.\n\n\n2.5.3 Define the Data\nThe data for the conceptual model includes both variables, and data modules. Variables can change their value throughout the simulation and are generally used to store some information temporarily before it is required later in the simulation. Data modules contain the information that is needed to perform the simulation and can be collected beforehand. Data mocules can also represent the input/experimental factors – the things that may change between different simulation scenarios. For each data module the following information should be given:\n\nThe name of the data module;\nThe source of the data, where the information was obtained;\nThe way the data is modelled, is it represented by a constant, a distribution, etc.\nWhether the output is deterministic or stochastic;\nThe inputs that the module requires;\nThe quantity that the module outputs.\n\nWhen presenting a conceptual model is useful to put the data first, as it is often referenced throughout the rest of the conceptual model.\n\n\n2.5.4 Define the Structure\nTo define the structure we start with formally defining the entities by listing them along with any attributes that they have. Some common attributes, such as ID number and the activity that the entity is currently participating in, are often omitted to avoid repitition. Attributes are usually included either to assist with the system behaviour – for example record whether a patient has had a test – or to capture the perfomance of the system – how long something has waited for.\nNext we define the transitions. Each arrow on a behavioural diagram corresponds to a transition. We can collate these in a table describing: the entity that is performing the transition, and the events that the entity transitions from and to. You can simply number them starting from 1, or adopt a convention of using the entity’s initial as a prefix.\nOnce the transitions have been defined we can define the activities and events. Usually these are presented in two tables, one for the activities and one for the events. For each event (either standalone or as part of an activity) the table should include:\n\nThe participant(s);\nThe type – either scheduled or controlled;\nThe state changes that occur when the event happens.\n\nThe main things that occur in state changes are:\n\nSchedule an end event – usually in the start event of an activity with a scheduled end event;\nStarting another activity/event – this usually happens in a scheduled end event where an entity is transitioning to another scheduled event;\nTrigger some logic – often in the start event of an activity with a controlled end event.\n\nThe simulation start event, and arrive events are often more complicated and involve scheduling the initial events and creating entities.\n\n\n2.5.5 Define the Logic\nThe final part of the conceptual model content is the logic. Each trigger that you drew in a behvioural path (the red squares) should correspond first to a trigger statement in the state changes of an event, and a piece of logic defined here. These pieces of logic are used to determine how the system behaves – what activity an entity should do next. It is common to have logic control the behaviour when one entity needs to wait for another, as when the first entity arrives it needs to check whether the other is free to perform an activity with it. The logic is usually presented as pseudocode, alongside the entity that triggers the logic.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/hccm_framework/hccm_framework.html#assumptions-and-simplifications",
    "href": "chapters/hccm_framework/hccm_framework.html#assumptions-and-simplifications",
    "title": "2  HCCM Framework",
    "section": "2.6 Assumptions and Simplifications",
    "text": "2.6 Assumptions and Simplifications\nThroughout the four phases of the HCCM framework you should document the assumptions and simplifications that you make. Assumptions are related to uncertainties about the system being modelled, and are used to fill in gaps in the information that is required for the simulation. Simplifications are changes that are made to the model to make it easier to defined or implement.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HCCM Framework</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "",
    "text": "3.1 Understanding of the Problem Situation\nIn the box below write a problem description for making paper cars, think about what you are trying to solve/discover by simulating this activity. You may want to look at Chapter 1 again to remind yourself about the process.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#modelling-objectives",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#modelling-objectives",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.2 Modelling Objectives",
    "text": "3.2 Modelling Objectives\nIn the box below write the modelling objectives for making paper cars, i.e., what are you trying to discover using simulation?",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#general-objectives",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#general-objectives",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.3 General Objectives",
    "text": "3.3 General Objectives\nIn the box below write the general objectives for making paper cars, i.e., what are some of the general properties you’d like your simulation to have?",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#defining-output-responses",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#defining-output-responses",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.4 Defining Output Responses",
    "text": "3.4 Defining Output Responses\nIn the box below write the output responses for making paper cars, i.e., what are you going to measure to determine the performance of the system?",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#defining-input-factors",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#defining-input-factors",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.5 Defining Input Factors",
    "text": "3.5 Defining Input Factors\nIn the box below write the input factors for making paper cars, i.e., what are you going to change to achieve the modelling objectives?",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#identifying-entities",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#identifying-entities",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.6 Identifying Entities",
    "text": "3.6 Identifying Entities\nIn the box below list the entities for making paper cars.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_io_behaviour/cm_io_behaviour.html#drawing-behavioural-paths",
    "href": "chapters/cm_io_behaviour/cm_io_behaviour.html#drawing-behavioural-paths",
    "title": "3  Inputs, Outputs, and Behaviour",
    "section": "3.7 Drawing Behavioural Paths",
    "text": "3.7 Drawing Behavioural Paths\nThe activity diagrams for the pencil & template, and scissors are given below in Figures 3.1, and 3.2.\n\n\n\n\n\n\nFigure 3.1: Pencil Activity Diagram\n\n\n\n\n\n\n\n\n\nFigure 3.2: Scissors Activity Diagram\n\n\n\n\nIn the boxes below draw the activity diagrams for the remaining entities.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Inputs, Outputs, and Behaviour</span>"
    ]
  },
  {
    "objectID": "chapters/cm_data_structure_logic/cm_data_structure_logic.html",
    "href": "chapters/cm_data_structure_logic/cm_data_structure_logic.html",
    "title": "4  Data, Structure, and Logic",
    "section": "",
    "text": "4.1 Define the Data\nFirstly, you need to give detailed definitions of the data modules. You may not have collected data during car making, but complete the following table that describes the kind of data you would need to collect to simulate car making. Also add a comment on how the entry for CutTapeDuration would change if no person-by-person data was available, but an Exponential distribution that estimated the time it takes for a person to cut tape was available.",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data, Structure, and Logic</span>"
    ]
  },
  {
    "objectID": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-data",
    "href": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-data",
    "title": "4  Data, Structure, and Logic",
    "section": "",
    "text": "Table 4.1: List of Data Modules\n\n\n\n\n\nName\nSource\nModel\nType\nInput\nOutput\n\n\n\n\nNumPencils\nSystem info\nConstant\nDeterministic\n-\nThe number of pencils available\n\n\nNumScissors\nSystem info\nConstant\nDeterministic\n-\nThe number of scissors available\n\n\nNumTape\nSystem info\nConstant\nDeterministic\n-\nThe number of rolls of tape available\n\n\nNum\nSystem info\nConstant\nDeterministic\n-\n\n\n\n\n\n\n\n\n\n\n\nTraceCar\nExperimental data\nLookup\nDeterministic\nPerson\nTime to trace car\n\n\nCutNet\nExperimental data\nLookup\nDeterministic\nPerson\nTime to cut the net out\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCutTape\nExperimental data\nLookup\nDeterministic\nPerson\nTime to cut a piece of tape",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data, Structure, and Logic</span>"
    ]
  },
  {
    "objectID": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-structure",
    "href": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-structure",
    "title": "4  Data, Structure, and Logic",
    "section": "4.2 Define the Structure",
    "text": "4.2 Define the Structure\nThe first part of the structure to define is the entities. Table 4.2 lists the entities again, but adds attributes that the entities will need to capture the performance of the system, e.g., waiting time until the cube was cut. It is assumed that all entities have the three attributes: ID, CurrentActivity, and CurrentStart. These are omitted in the table to prevent repetition.\n\n\n\nTable 4.2: List of Entities\n\n\n\n\n\nEntity\nAttributes\n\n\n\n\nPaper\nWaitForTrace[0.0]\n\n\n\nWaitForCutShape[0.0]\n\n\n\nWaitForFold[0.0]\n\n\n\nWaitForTapeCube[0.0]\n\n\n\n\n\n\nPencil\nWaitForTrace[0.0]\n\n\n\n\n\n\nScissors\nWaitForTask[0.0]\n\n\n\n\n\n\nTape\nWaitForCut[0.0]\n\n\n\n\n\n\nTapePieces\nWaitForTape[0.0]\n\n\n\nArrivalTime[0.0]\n\n\n\nLeavingTime[0.0]\n\n\nPerson\nWaitForTask[0.0]\n\n\n\n\n\n\nThe next part of the structure is the transitions, which describe how entities move between activities and events. Table 4.3 lists the transitions for making paper cars. These transitions are prefixed by entity of the behavioural pathway they come from. Complete the transitions for the Scissors pathway.\n\n\n\nTable 4.3: List of Transitions\n\n\n\n\n\n\nParticipant\nName\nFrom Event\nTo Event\n\n\n\n\nPaper\nPAP.1\nPaper Created\nPaper Wait for Trace.Start\n\n\n\nPAP.2\nPaper Wait for Trace.End\nTrace Car.Start\n\n\n\nPAP.3\nTrace Car.End\nPaper Wait for Cut Net.Start\n\n\n\nPAP.4\nPaper Wait for Cut Net.End\nCut Car Net.Start\n\n\n\nPAP.5\nCut Car Net.End\nCar Wait for Fold.Start\n\n\n\nPAP.6\nCar Wait for Fold.End\nFold Car.Start\n\n\n\nPAP.7\nFold Car.End\nCar Wait for Tape.Start\n\n\n\nPAP.8\nCar Wait for Tape.End\nTape Car.Start\n\n\n\nPAP.9\nTape Car.End\nCar Finished\n\n\n\n\n\n\n\n\nPencil\nPEN.1\nPencil/Template Created\nPencil Wait for Trace.Start\n\n\n\nPEN.2\nPencil Wait for Trace.End\nTrace Car.Start\n\n\n\nPEN.3\nTrace Car.End\nPencil Wait for Trace.Start\n\n\n\n\n\n\n\n\nScissors\nS.1\nScissors Created\n\n\n\n\nS.2\n\n\n\n\n\nS.3\n\n\n\n\n\nS.4\n\n\n\n\n\nS.5\n\n\n\n\n\n\n\n\n\n\nTape\nT.1\nTape Created\nTape Wait for Cut.Start\n\n\n\nT.2\nTape Wait for Cut.End\nCut Tape.Start\n\n\n\nT.3\nCut Tape.End\nTape Wait for Cut.Start\n\n\n\n\n\n\n\n\nTape Piece\nTP.1\nTape Pieces Created\nTape Pieces Wait for Tape.Start\n\n\n\nTP.2\nTape Pieces Wait for Tape.End\nTape Car.Start\n\n\n\nTP.3\nTape Car.End\nTape Pieces Leave\n\n\n\n\n\n\n\n\nPerson\nPER.1\nPerson Created\nPerson Wait for Task.Start\n\n\n\nPER.2\nPerson Wait for Task.End\nTrace Car.Start\n\n\n\nPER.3\nTrace Car.End\nPerson Wait for Task.Start\n\n\n\nPER.4\nPerson Wait for Task.End\nCut Car Net.Start\n\n\n\nPER.5\nCut Car Net.End\nPerson Wait for Task.Start\n\n\n\nPER.6\nPerson Wait for Task.End\nFold Car.Start\n\n\n\nPER.7\nFold Car.End\nPerson Wait for Task.Start\n\n\n\nPER.8\nPerson Wait for Task.End\nCut Tape.Start\n\n\n\nPER.9\nCut Tape.End\nPerson Wait for Task.Start\n\n\n\nPER.10\nPerson Wait for Task.End\nTape Car.Start\n\n\n\nPER.11\nTape Car.End\nPerson Wait for Task.Start\n\n\n\n\n\n\n\nTable 4.4 lists the activities from the behavioural pathway diagrams along with the state changes for the start and end event of each activity. Complete the activities for:\n\nCar Wait for Tape Car\nTape Car\nPerson Wait for Task (Hint look at Scissors Wait for Task)\n\n\n\n\nTable 4.4: Activities\n\n\n\n\n\n\nActivity\nParticipants\nEvent\nType\nState Change\n\n\n\n\nPaper Wait for Trace\nPaper (P)\nStart\nScheduled\n(Default, omitted hereafter) P.CurrentActivity = \"this activity\"\n(Default, omitted hereafter) P.CurrentStart = TIME\nTRIGGER OnStartPaperWaitForTrace WITH C\n\n\n\n\nEnd\nControlled\nP.WaitForTrace = TIME - P.CurrentStart\n# TRANSITION PAP.2 in logic\n\n\nTrace Car\nPaper (P), Person (H), Pencil (N)\nStart\nControlled\nSCHEDULE END at TIME + TraceCube(H)\n\n\n\n\nEnd\nScheduled\nSTART Paper Wait for Cut Net WITH P # TRANSITION PAP.3\nSTART Person Wait for Task WITH H # TRANSITION PER.3\nSTART Pencil Wait for Trace WITH N # TRANSITION PEN.3\n\n\nPaper Wait for Cut Net\n\nStart\n\nTRIGGER OnStartPaperWaitForCutNet WITH P\n\n\n\n\nEnd\n\nP.WaitForCutNet = TIME - P.CurrentStart\n# TRANSITION PAP.4 in logic\n\n\nCut Car Net\nPaper (P), Person (H), Scissors (S)\nStart\nControlled\nSCHEDULE END at TIME + CutNet(H)\n\n\n\n\nEnd\nScheduled\nSTART Car Wait for Fold WITH P # TRANSITION PAP.5\nSTART Person Wait for Task WITH H # TRANSITION PER.5\nSTART Scissors Wait for Task WITH S # TRANSITION S.3\n\n\nCar Wait for Fold\nPaper (P)\nStart\nScheduled\nTRIGGER OnStartCarWaitForFold WITH P\n\n\n\n\nEnd\nControlled\nP.WaitForFold = TIME - P.CurrentStart\n# TRANSITION PAP.6 in logic\n\n\nFold Car\nPaper (P), Person (H)\nStart\nControlled\nSCHEDULE END at TIME + FoldCar(H)\n\n\n\n\nEnd\nScheduled\nSTART Car Wait for Tape Car WITH P # TRANSITION PAP.7\nSTART Person Wait for Task WITH H # TRANSITION PER.7\n\n\nCar Wait for Tape Car\n\nStart\n\n \n\n\n\n\nEnd\n\n \n \n\n\nTape Car\n\nStart\n\n \n\n\n\n\nEnd\n\n \n \n \n\n\nPencil Wait for Trace\nPencil (N)\nStart\nScheduled\nTRIGGER OnStartPencilWaitForTrace WITH N\n\n\n\n\nEnd\nControlled\nN.WaitForTrace = N.WaitForTrace + TIME - N.CurrentStart\n# TRANSITION N.2 in logic\n\n\nScissors Wait for Task\nScissors (S)\nStart\nScheduled\nTRIGGER OnStartScissorsWaitForTask WITH S\n\n\n\n\nEnd\nControlled\nS.WaitForTask = S.WaitForTask + TIME - S.CurrentStart\n# TRANSITION S.2 or S.4 in logic\n\n\nCut Tape\nTape (T), Person (H), Scissors (S)\nStart\nControlled\nSCHEDULE END at TIME + CutTape(H)\n\n\n\n\nEnd\nScheduled\nSTART Person Wait for Task WITH H # TRANSITION PER.9\nSTART Scissors Wait for Task WITH S # TRANSITION S.5\nSTART Tape Wait for Cut WITH T # TRANSITION T.3\nCREATE Tape Pieces TP\nSTART Tape Pieces Created WITH TP\n\n\nTape Wait for Cut\nTape (T)\nStart\nScheduled\nTRIGGER OnStartTapeWaitForCut WITH T\n\n\n\n\nEnd\nControlled\nT.WaitForCut = T.WaitForCut + TIME - T.CurrentStart\n# TRANSITION T.2 in logic\n\n\nTape Pieces Wait for Tape\nTape Pieces (TP)\nStart\nScheduled\nTRIGGER OnStartTapePiecesWaitForTape WITH TP\n\n\n\n\nEnd\nControlled\nTP.WaitForTape = TP.WaitForTape + TIME - TP.CurrentStart\n# TRANSITION TP.2 in logic\n\n\nPerson Wait for Task\n\nStart\n\n \n\n\n\n\nEnd\n\n \n \n\n\n\n\n\n\n\nTable 4.5 lists the events to start and finish the simulation along with the events from the behavioural pathway diagrams along with the state changes for each event. Complete the activities for:\n\nTape Pieces Created\nPerson Created\n\n\n\n\nTable 4.5: Events\n\n\n\n\n\n\nEvent\nParticipants\nType\nState Change\n\n\n\n\nSimulation Start\nNone\nScheduled\nFOR NumPaper DO\n  CREATE Paper P\n  START Paper Created WITH P\nEND FOR\nFOR NumPencils DO\n  CREATE Pencil N\n  START Pencil/Template Created WITH N\nEND FOR\nFOR NumScissors DO\n  CREATE Scissors S\n  START Scissors Created WITH S\nEND FOR\nFOR NumTape DO\n  CREATE Tape T\n  START Tape Created WITH T\nEND FOR\nFOR NumPeople DO\n  CREATE Person H\n  START Person Created WITH H\nEND FOR\n\n\nPaper Created\nPaper (P)\nScheduled\nSTART Paper Wait for Trace WITH P # TRANSITION PAP.1\n\n\nCar Finished\nPaper (P)\nScheduled\nCalculate statistics for P\n\n\nPencil/ Template Created\nPencil (N)\nScheduled\nSTART Pencil Wait for Trace WITH N # TRANSITION PEN.1\n\n\nScissors Created\nScissors (S)\nScheduled\nSTART Scissors Wait for Task WITH S # TRANSITION S.1\n\n\nTape Created\nTape (T)\nScheduled\nSTART Tape Wait for Cut WITH T # TRANSITION T.1\n\n\nTape Pieces Created\n\n\n  \n\n\nTape Pieces Leave\nTape Pieces (TP)\nScheduled\nCalculate statistics for TP\n\n\nPerson Created\n\n\n \n\n\nSimulation Finish\nNone\nScheduled\nCalculate statistics as required for Pencils, Scissors, Tape, Person entities",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data, Structure, and Logic</span>"
    ]
  },
  {
    "objectID": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-logic",
    "href": "chapters/cm_data_structure_logic/cm_data_structure_logic.html#define-the-logic",
    "title": "4  Data, Structure, and Logic",
    "section": "4.3 Define the Logic",
    "text": "4.3 Define the Logic\nThe last part of the structure to define is the logic. You need to define the logic for each of the triggers (the red squares in the behavioural paths, and TRIGGER statements in the state changes). Tables XXX show the logic for some of the triggers. Complete the logic for: - On Tape Wait for Cut.Start - On Cube Wait for Fold.Start - the last condition of On Person Wait for Task.Start\n\n\n\nTable 4.6: OnStartPencilWaitForTrace\n\n\n\n\n\n\n\nTriggered by: Pencil N\n\n\n\n\n\nIF (any Paper P with P.CurrentActivity = Paper Wait for Trace) AND\n   (any Person H with H.CurrentActivity = Person Wait for Task) THEN\n    SELECT valid Paper P\n    SELECT valid Person H\n    START Trace Car WITH P, H, N\nEND IF",
    "crumbs": [
      "Conceptual Modelling Labs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data, Structure, and Logic</span>"
    ]
  },
  {
    "objectID": "chapters/vscode_java_setup/vscode_java_setup.html",
    "href": "chapters/vscode_java_setup/vscode_java_setup.html",
    "title": "5  Setting Up VSCode and Java",
    "section": "",
    "text": "In this lab you will walk through the set up of running a Java program in VSCode. You will need to be able to do this to implement HCCMs in Jaamsim.\nIf you do not already have VSCode installed on your machine, download and install the version appropriate for your operating system from here.\n\nIf you are using your own laptop, it is best to install a recent version of the Java JDK (unless you are confident you already have a recent version). We recommend Amazon Corretto 21. You can download it from here, and then install it.\nThe videos provided on this page are also available here.\nOpen VSCode, then on the left-hand side click on the Extensions tab. Search for the ‘Extension Pack for Java’ and install it.\n\nCreate a new folder called ENGSCI355, if you are using a lab computer create this folder on your H drive. If you aren’t, then create it within Documents or wherever you usually keep University related work. Inside the ENGSCI355 folder create another folder called Java_Example. Then in VSCode open this folder by going File -&gt; Open Folder, then navigating to the Java_Example folder.\n\n\nOnce you have opened the folder in VSCode, create a new file in it called Hello.java. Once you have that file (or any .java file) open VSCode should detect that you are editing a java file and, if there isn’t one already, create a Java Project in the same folder. You should see that the ‘Java Projects’ section has been enabled in the bottom left of the screen.\n\nWe now want to make sure that this Java Project is using the correct Java JDK. Hover your mouse over the ‘Java Projects’ title and then click on the three dots that appear on the right hand side (with the tooltip ‘More Actions’), and select ‘Configure Java Runtime’. Use the drop-down menu that appears to select the Amazon Corretto 21 JDK. If it is not on the list, select ‘Find a local JDK’ and browse to the location that you installed the Amazon Corretto JDK.\n\nNow go back to the Hello.java file and add the following code:\npublic class Hello {\n  public static void main(String[] args) {\n    System.out.println(\"Hello!\");\n  }\n}\nTo run the program either click on the ‘Run’ button just above the line that declares the main function, or click on the run button in the top right corner of the screen. You should see a line with ‘Hello!’ printed by itself.\n\nYou have now create and run a Java program! If you run into any issues, there are more detailed instructions available here.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setting Up VSCode and Java</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "",
    "text": "6.1 Prerequisites\nThese instructions were prepared using:\nThey should work with more recent versions of the software too. All of this software is standard on Engineering lab machines. Amazon Corretto JRE 21 is available on the University of Auckland’s Software Centre.\nThe videos provided on this page are also available here.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#prerequisites",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#prerequisites",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "",
    "text": "Git – 2.47.0.2;\nGitHub Desktop – 3.4.8 (x64);\nJava – Amazon Corretto JRE 21;\nVSCode – 1.95.1.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#create-the-project-folder-structure",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#create-the-project-folder-structure",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.2 Create the Project Folder Structure",
    "text": "6.2 Create the Project Folder Structure\nCreate a new folder on your H drive called ENGSCI355. Then create three folders within this one, called sim, labs, and workspace. The sim folder will contain the java code for the simulation software Jaamsim, including custom code that you write, and is the focus of these instructions. The labs folder will contain subfolders for each lab with the simulation files for each. Create a folder for HCCM logic functions within the sim folder. We will use sim_custom in these instructions.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#clone-hccm-into-the-project-folder",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#clone-hccm-into-the-project-folder",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.3 Clone HCCM into the project folder",
    "text": "6.3 Clone HCCM into the project folder\nOpen GitHub Desktop and go to File \\(\\rightarrow\\) Clone repository, then select the URL tab and enter\n\nhttps://github.com/mosu001/hccm\n\nas the URL. Choose the Local path to be the sim folder that you just created.\ninto an hccm folder within the sim folder. This will create an hccm folder within the sim folder that contains the HCCM and Jaamsim code.\nNote, if you use git from the command line, e.g., Git Bash, you need to add the recurse submodules option\ngit clone --recurse-submodules https://github.com/mosu001/hccm",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#create-files-to-load-hccm-and-customised-components",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#create-files-to-load-hccm-and-customised-components",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.4 Create files to load HCCM and customised components",
    "text": "6.4 Create files to load HCCM and customised components\nFrom hccm_custom copy both autoload.cfg and hccm.inc into the sim_custom folder. Then open autoload.cfg with VSCode and edit it so that the content matches that in Figure 6.1.\n\n\n\nInclude units.inc\nInclude sim.inc\nInclude units-imperial.inc\nInclude units-knots.inc\nInclude displayModels.inc\nInclude graphics.inc\nInclude probabilityDistributions.inc\nInclude basicObjects.inc\nInclude resourceObjects.inc\nInclude examples.inc\nInclude processFlow.inc\nInclude calculationObjects.inc\nInclude fluidObjects.inc\nInclude submodels.inc\nInclude hccm.inc\nInclude sim_custom.inc\n\n\nFigure 6.1: Customised autoload.cfg File\n\n\n\nThen rename hccm.inc to sim_custom.inc, open it in VSCode, and delete all the contents so it is blank. Don’t forget to save both autoload.cfg and sim_custom.inc.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#create-a-vscode-java-project",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#create-a-vscode-java-project",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.5 Create a VSCode Java Project",
    "text": "6.5 Create a VSCode Java Project\nIn VSCode use File \\(\\rightarrow\\) Open Folder to open the sim folder. In the File Explorer open some folder so that you can see a .java file and open it, for example: hccm\\custom\\hccm\\Constants.java. VSCode should then recognise that you have opened a Java file and the Java Projects pane should appear.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#configure-source-folders",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#configure-source-folders",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.6 Configure Source Folders",
    "text": "6.6 Configure Source Folders\nNow we need to tell VSCode where the source code of the project is. To do this we click on the three dots at the right of the ‘Java Projects’ title and select ‘Configure Classpath’. A new menu should come up that allows you to add and remove sources. If anything other than hccm\\custom is already there remove it by clicking on the x on the far right hand side, then ‘Apply Settings’. Add new sources by clicking on ‘Add Source Root’. First add sim\\hccm\\jaamsim\\src\\main\\java, then click ‘Apply Settings’. Then add both sim\\hccm\\jaamsim\\src\\main\\resources and sim\\sim_custom, remembering to apply the settings after each one.\nYou can check to make sure that you have the correct sources configured by opening the settings.json file in the .vscode folder. Under “java.project.sourcePaths” there should be the following four entries:\n\nhccm\\\\custom\nhccm\\\\jaamsim\\\\src\\\\main\\\\java\nhccm\\\\jaamsim\\\\src\\\\main\\\\resources\nsim_custom",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#configure-jdk",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#configure-jdk",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.7 Configure JDK",
    "text": "6.7 Configure JDK\nWe need to make sure that VSCode is using the version of Java that we want it to. To do this we click on the three dots at the right of the ‘Java Projects’ title and select ‘Configure Java Runtime’. A drop-down menu for JDK should come up. Make sure that JavaSE-21 is selected and then click ‘Apply Settings’.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#configure-libraries",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#configure-libraries",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.8 Configure Libraries",
    "text": "6.8 Configure Libraries\nJaamSim also needs the gluegen and jogl libraries to run. These are packaged with JaamSim as .jar files (a compiled Java program). They can be added by opening the project settings by clicking on the three dots at the right of the ‘Java Projects’ title and selecting either ‘Configure Java Runtime’ or ‘Configure Classpath’. Then select the ‘Libraries’ tab on the right. Click on ‘Add Library’, then navigate to hccm\\jaamsim\\jar, select all of the files, and click ‘Select Jar File’. Then click ‘Apply Settings’.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#integrate-with-jaamsim",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#integrate-with-jaamsim",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.9 Integrate with JaamSim",
    "text": "6.9 Integrate with JaamSim\nTo integrate HCCM and any custom logic with JaamSim you need to copy your autoload.cfg and sim_custom.inc files (from sim_custom) to sim\\hccm\\jaamsim\\src\\main\\resources\\resources\\inputs and replace the autoload.cfg file that is currently there. You also need to copy the file hccm.inc in hccm\\custom to the same location. To check that they have been copied correctly you can look in the ‘Java Projects’ section on the left-hand side. Under hccm\\jaamsim\\src\\main\\resources\\resources\\inputs you should see both hccm.inc and sim_custom.inc. If you don’t, try using the menu accessed by clicking the three dots and selecting ‘Refresh’.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#run-custom-jaamsim",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#run-custom-jaamsim",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.10 Run Custom JaamSim",
    "text": "6.10 Run Custom JaamSim\nYou should now be able to run JaamSim with the HCCM objects enabled. Start by clicking on the ‘Run and Debug’ menu on the left-hand side, then click on ‘create a launch.json file’, and select ‘Java’ from the list of debuggers that comes up in the middle of the screen. By doing this VSCode analyses the source code to determine which java files you might like to run and creates run configurations for each of them. In the file that is created you should see an entry with the name ‘GUIFrame’, this is the class that we need to run to start JaamSim. To make the view work correctly when JaamSim is running you need to add another parameter called “vmArgs” with the following entries enclosed in double quotes and separated by spaces on a single line:\n\n--add-exports java.base/java.lang=ALL-UNNAMED\n--add-exports java.desktop/sun.awt=ALL-UNNAMED\n--add-exports java.desktop/sun.java2d=ALL-UNNAMED\n\nThe final entry in the .launch file should look like this:\n\n\"type\": \"java\",\n\"name\": \"GUIFrame\",\n\"request\": \"launch\",\n\"mainClass\": \"com.jaamsim.ui.GUIFrame\",\n\"projectName\": \"sim_d11998cc\",\n\"vmArgs\": \"--add-exports java.base/java.lang=ALL-UNNAMED --add-exports java.desktop/sun.awt=ALL-UNNAMED --add-exports java.desktop/sun.java2d=ALL-UNNAMED\"\n\nThen, in the top left-hand corner next to the green play button click on the drop-down menu and select ‘GUIFrame’. Then click the green play button to run JaamSim. The launch screen should appear but you might also have to click on the JaamSim icon in the Taskbar at the bottom of the screen to open JaamSim. You should see the ‘HCCM’ palette at the bottom of the ‘Model Builder’ window, and be able to drag and drop objects into the View.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/jaamsim_setup/jaamsim_setup.html#running-an-hccm-model",
    "href": "chapters/jaamsim_setup/jaamsim_setup.html#running-an-hccm-model",
    "title": "6  Setting Up JaamSim and HCCM",
    "section": "6.11 Running an HCCM Model",
    "text": "6.11 Running an HCCM Model\nNow that we have JaamSim running with the HCCM objects we can try running an existing model. Download the single server queue model’s folder from Canvas (ssq.zip), move it into the labs folder and extract ssq.zip into that folder. You might want to remove the ssq at the end of the extraction destination to prevent nested ssq folders being created.\nNow we need to create package in our Java Project to hold the custom logic associated with this model. In VSCode right-click on the sim_custom folder and select New Java Package. Enter ssq for the name of the package and click Finish. This will have created a new folder in the sim_custom folder called ssq.\nNow go back to the ssq folder you extracted the zip file to and copy the FIFOQControlUnit.java file to the newly created package folder under sim\\sim_custom\\ssq. This java file defines a new Jaamsim object, in this case the control unit for the SSQ model.\n\nFinally we need to make this new object available in Jaamsim. To do this we need to edit the sim_custom.inc file that we put in sim\\hccm\\jaamsim\\src\\main\\resources\\resources\\inputs. Open the sim_custom.inc file and also open the ssq.inc file in the ssq folder. Copy the contents of ssq.inc into sim_custom.inc.\nRun JaamSim with HCCM from the Run and Debug menu again (make sure that GUIFrame is selected in the drop-down). You should now see a Single Server Queue palette in the Model Builder window. It has the FIFO trigger for the Single Server Queue model (you will learn more about triggers in later labs).\nNext in Jaamsim in the top left corner select file, then open, and open ssq.cfg from the ssq folder. You can run the model by clicking on the blue play button in the top left and see how the customers and servers join together for service in the queue.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Setting Up JaamSim and HCCM</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1/clinic_1.html",
    "href": "chapters/clinic_1/clinic_1.html",
    "title": "7  Radiology Clinic",
    "section": "",
    "text": "7.1 Experiments\nWe will perform just one experiment, using distributions for the arrival, check in, and scan processes. We will use a Poisson distribution with \\(\\lambda=8/\\text{hour}\\) for the arrival process, a uniform distribution between 2 and 5 minutes for the check in durations, and a log-normal distribution where the underlying normal variable has a mean of -1.34 and standard deviation 0.29 for the scan durations. For the experiment we will run 50 replications that each last for 1 week.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1/clinic_1.html#jaamsim-model",
    "href": "chapters/clinic_1/clinic_1.html#jaamsim-model",
    "title": "7  Radiology Clinic",
    "section": "7.2 Jaamsim Model",
    "text": "7.2 Jaamsim Model\n\n7.2.1 Creating Model Objects\nRun Jaamsim by opening your VSCode project and the clicking the run button and select GUIFrame. The HCCM palette on the left hand side allows us to create Jaamsim objects that correspond to the components of our HCCM conceptual models. Based on the problem description and conceptual model we need three types of entities: patients, receptionists, and CT Machines. To create each of these expand the HCCM palette in the Model Builder window, select ActiveEntity, and dragging it into the View Window, see Figure 7.1. Then in the Object Selector window select ActiveEntity1, press F2, and rename it PatientEntity.\n\n\n\n\n\n\n\nFigure 7.1: Screenshot of an ActiveEntity\n\n\nRepeat this process two more times and create ActiveEntities called ReceptionistEntity and CTMachineEntity.\nAn ActiveEntity object by itself does not create any entities in the simulation, it just acts as a prototype for entities. To create entities an ArriveEvent object is used, which simulates patients/receptionists/CTMachines arriving at the clinic. The ArriveEvent object creates a series of entities that are passed to the next object in a process. The PrototypeEntity keyword identifies the entity to be copied. The rate at which entities are generated is determined by the InterArrivalTime and FirstArrivalTime keywords. Create three ArriveEvents called PatientArrival, ReceptionistArrival, and CTMachineArrival, and set the PrototypeEntity to be the related entity (patient, receptionist, CTMachine).\nWe also need to create objects that represent the entities leaving, called LeaveEvent, we will only create one for the patients, as we are assuming that the receptionist and CT machines are available 24/7 so they do not need to leave. Drag and drop a leave event into the simulation, rename it PatientLeave, and set the Participant to be the patient entity (under the HCCM tab).\nThe patients waiting for check in and scanning, and both the receptionist and CT machines waiting for tasks can be represented by WaitActivities, so create four WaitActivities and rename them WaitForCheckIn, WaitForScan, WaitForTaskReceptionist, and WaitForTaskCTMachine respectively, and once again set the Participant to the respective entity.\nWe can then represent the patient doing check in with the receptionist, and the patient being scanned by a CT machine as process activities. Create two process activities and rename them CheckIn, and Scan.\nWe also need to create objects to represent the probability distributions that the interarrival, check in, and scan times come from. Probability distributions can be represented in Jaamsim with distribution objects. If we examine the PatientArrival object we see two keywords FirstArrivalTime and InterArrivalTime which determine the rate that the entities are created. For a Poisson process with an average of 8 arrivals per hour the interarrival times can be modelled by an exponential distribution with mean 0.125 hours. We therefore go into the Probability Distributions palette in the Model Builder window and create an ExponentialDistribution object and name it ArrivalDistribution. First we set the UnitType keyword to be TimeUnit, then we set the mean of the distribution to 0.125 h. The UnitType tells Jaamsim what type of value we want the distribution object to create, in our case this is the time between arrivals in hours, which is a unit of time. Also make sure that the RandomSeed is 1, this determines the seed for the random number generator. Table 7.1 shows the keywords and values for the ArrivalDistribution object.\n\n\n\nTable 7.1: Arrival Distribution Inputs\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nArrivalDistribution\nUnitType\nTimeUnit\n\n\n\nRandomSeed\n1\n\n\n\nMean\n0.125 h\n\n\n\n\n\n\nWe need to repeat these steps for the check in and scan processes, which follow uniform and log-normal distributions respectively, so create a UniformDistribution object called CheckInDistribution and a LogNormalDistribution object called ScanDistribution. Then update the keywords of the distribution objects as follows in Table 7.2:\n\n\n\nTable 7.2: Check In and Scan Distributions\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nCheckInDistribtuion\nUnitType\nTimeUnit\n\n\n\nRandomSeed\n2\n\n\n\nMinValue\n2 min\n\n\n\nMaxValue\n5 min\n\n\n\n\n\n\n\nScanDistribution\nUnitType\nTimeUnit\n\n\n\nRandomSeed\n3\n\n\n\nScale\n1 h\n\n\n\nNormalMean\n-1.34\n\n\n\nNormalSD\n0.29\n\n\n\n\n\n\nThe final object we need at this stage is a Statistics object, to capture some output about the patients. This is found under the ProcessFlow palette, create a Statistics object and call it TimeInSystem.\nAt this point you should have the objects shown in Table 7.3 in your simulation.\n\n\n\nTable 7.3: Model Objects\n\n\n\n\n\nObject Type\nName\n\n\n\n\nActiveEntity\nPatientEntity\n\n\nActiveEntity\nReceptionistEntity\n\n\nActiveEntity\nCTMachineEntity\n\n\n\n\n\n\nArriveEvent\nPatientArrival\n\n\nArriveEvent\nReceptionistArrival\n\n\nArriveEvent\nCTMachineArrival\n\n\n\n\n\n\nLeaveEvent\nPatientLeave\n\n\n\n\n\n\nWaitActivity\nWaitForCheckIn\n\n\nWaitActivity\nWaitForScan\n\n\nWaitActivity\nWaitForTaskReceptionist\n\n\nWaitActivity\nWaitForTaskCTMachine\n\n\n\n\n\n\nProcessActivity\nCheckIn\n\n\nProcessActivity\nScan\n\n\n\n\n\n\nExponentialDistribution\nArrivalDistribution\n\n\nUniformDistribution\nCheckInDistribution\n\n\nLogNormalDistribution\nScanDistribution\n\n\n\n\n\n\nStatistics\nTimeInSystem\n\n\n\n\n\n\nOnce you have created all of these objects lay them out similarly to as shown in Figure 7.2.\n\n\n\n\n\n\nFigure 7.2: Screenshot of Simulation Model Layout\n\n\n\nCreate a new folder in the labs folder called RC1 and save your simulation as radiology_lab.cfg or something similar inside the new folder. Also take this opportunity to change the graphics of the PatientEntity, ReceptionistEntity and CTMachineEntity. Download the patient.png, receptionist.png, and ctscanner.png (icons made by Freepik from www.flaticon.com) files from Canvas and save them in the same folder as your simulation .cfg file. Then in Jaamsim right click on PatientEntity and select Change Graphics. Click on Import and navigate to your downloaded patient.png, import it (it may be called patient-model) and accept the change. Repeat the process for the receptionists, and CT scanners.\n\n\n7.2.2 Configuring Objects\nNow that we have created the objects we need, we need to set the options for the each of them, starting with the ArriveEvents. The PatientArrival should have both the first arrival time and inter arrival times set by the ArrivalDistribution object, use the PatientEntity as a prototype, and the NextAEJObject should be WaitForCheckIn. NextAEJObject stands for next activity/event/Jaamsim object and refers to the fact that the next place an entity goes could be a standard Jaamsim object or a custom HCCM activity or event. For the arrive events we set NextAEJObject to the object that represents the activity that is transitioned to at the end of the event state changes in the conceptual model. For the ReceptionistArrival and CTMachineArrival we need to: set the prototype entity; both MaxNumber and InitialNumber (1 for receptionist, 3 for CT Machine); and set the NextAEJObject to the respective wait activity.\n\n\n\nTable 7.4: Arrival Event Parameters\n\n\n\n\n\nObject\nTab\nKeyword\nValue\n\n\n\n\nPatientArrival\nKey Inputs\nPrototypeEntity\nPatientEntity\n\n\nPatientArrival\nKey Inputs\nFirstArrivalTime\nArrivalDistribution\n\n\nPatientArrival\nKey Inputs\nInterArrivalTime\nArrivalDistribution\n\n\nPatientArrival\nHCCM\nNextAEJObject\nWaitForCheckIn\n\n\n\n\n\n\n\n\nReceptionistArrival\nKey Inputs\nPrototypeEntity\nReceptionistEntity\n\n\nReceptionistArrival\nKey Inputs\nMaxNumber\n1\n\n\nReceptionistArrival\nKey Inputs\nInitialNumber\n1\n\n\nReceptionistArrival\nHCCM\nNextAEJObject\nWaitForTaskReceptionist\n\n\n\n\n\n\n\n\nCTMachineArrival\nKey Inputs\nPrototypeEntity\nCTMachineEntity\n\n\nCTMachineArrival\nKey Inputs\nMaxNumber\n3\n\n\nCTMachineArrival\nKey Inputs\nInitialNumber\n3\n\n\nCTMachineArrival\nHCCM\nNextAEJObject\nWaitForTaskCTMachine\n\n\n\n\n\n\nNext we will set the options for the Process Activities (and Statistics) so that the routing/flow for the entities is correct. The Check In activity has both the Patient and Receptionist as participants so we set the Participant list to PatientEntity, ReceptionistEntity. The duration is determined by the check in distribution, so we just set the duration to be CheckInDistribution object. After Check In the Patient starts waiting for a scan and the receptionist goes back to waiting for a task, so we set the NextAEJList to WaitForScan, WaitForTaskReceptionist. The Scan activity has both the Patient and CTMachine as participants and the duration is determined by the ScanDistribution object. After Scan the Patient should just leave, but we want to record some statistics first so we send it to TimeInSystem, and the CTMachine goes back to WaitForTaskCTMachine. For Process Activities the NextAEJList is similar to the NextAEJObject from the Arrive Events (which is similar to NextComponent), the difference is that a list of next objects is given, one for each of the participants in the activity. The participants are sent to the corresponding element of the list so it is important that the next activities are in the same order as the participants.\nNote that when you click on the checkboxes in the popup menu for both ParticipantList and NextAEJList the items are added in alphabetical order, not the order you click them in. This is particularly important for the Scan activity as the CTMachineEntity comes before the PatientEntity alphabetically, but for the next activities TimeInSystem is before WaitForTaskCTMachine alphabetically so the two lists will not be in the same order.\n\n\n\nTable 7.5: Process Activity Parameters\n\n\n\n\n\nObject\nTab\nKeyword\nValue\n\n\n\n\nCheckIn\nKey Inputs\nDuration\nCheckInDistribution\n\n\nCheckIn\nHCCM\nParticipantList\nPatientEntity ReceptionistEntity\n\n\nCheckIn\nHCCM\nNextAEJList\nWaitForScan WaitForTaskReceptionist\n\n\n\n\n\n\n\n\nScan\nKey Inputs\nDuration\nScanDistribution\n\n\nScan\nHCCM\nParticipantList\nPatientEntity CTMachineEntity\n\n\nScan\nHCCM\nNextAEJList\nTimeInSystem WaitForTaskCTMachine\n\n\n\n\n\n\nThe last object we need to configure before the simulation will run (it will run but it will not quite work correctly) is the TimeInSystem object. This is a Statistics object which collects a value from each Entity that passes through it and outputs the mean of the sampled values. We then need to finish the routing so that patients leave after going through the TimeInSystem, and tell the Statistics object which value to record as shown in Table 8.7, note that this refers to the Statistics object itself, obj refers to the entity that the Statistics object is currently processing, and TotalTime is an output on the entity that stores the total time that the entity has been in the simulation for.\n\n\n\nTable 7.6: Collecting Statistics\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nTimeInSystem\nNextComponent\nPatientLeave\n\n\n\nUnitType\nTimeUnit\n\n\n\nSampleValue\nthis.obj.TotalTime\n\n\n\n\n\n\nSave your simulation again. If you run your simulation now you should see one receptionist arrive and wait, three CT machines arrive and wait, and patients arrive, and wait for check in. However nothing else will happen and all of the entities will simply be waiting, this is because we have not specified any logic to be triggered when the entities start waiting.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1/clinic_1.html#model-logic-java",
    "href": "chapters/clinic_1/clinic_1.html#model-logic-java",
    "title": "7  Radiology Clinic",
    "section": "7.3 Model Logic – Java",
    "text": "7.3 Model Logic – Java\nIn your VSCode project you should have a folder called sim_custom under the Explorer tab on the left-hand side in VSCode. First right-click on this folder and select New Java Package. Enter labs for the name of the package and press Enter.\n\n\n\n\n\n\nFigure 7.3: First Step in Creating a New Package\n\n\n\n\n\n\n\n\n\nFigure 7.4: Second Step in Creating a New Package\n\n\n\nA new folder called labs should have been created within the sim_custom folder. Right click on the newly created labs folder and select New Java File \\(\\rightarrow\\) Class. Name the Class RadiologyControlUnit and press Enter.\n\n\n\n\n\n\nFigure 7.5: First Step in Creating a New Class\n\n\n\n\n\n\n\n\n\nFigure 7.6: Second Step in Creating a New Class\n\n\n\n\nThe final step required to make this new object available in the simulation is to add to the contents of the sim_custom.inc file that we put in sim \\(\\rightarrow\\) hccm \\(\\rightarrow\\) jaamsim \\(\\rightarrow\\) src \\(\\rightarrow\\) main \\(\\rightarrow\\) resources \\(\\rightarrow\\) resources \\(\\rightarrow\\) inputs. There should already be some code there from the previous lab, so you only need to add lines 3, 7, and 10. If you want to copy and paste this make sure the quotes are copied correctly and the returns (arrows) are removed. Alternatively there is a new sim_custom.inc file here XXX on Canvas under Jaamsim Lab 1 that you can use directly.\n\nDefine ObjectType {\n    FIFOQControlUnit\n    RadiologyControlUnit\n}\n\nControllerIconModel ImageFile { '&lt;res&gt;/images/Controller-256.png' }  Transparent { TRUE }\nAssembleIconModel ImageFile { '&lt;res&gt;/images/Assemble-256.png' }  Transparent { TRUE }\n\nFIFOQControlUnit JavaClass { ssq.FIFOQControlUnit }  Palette { 'Single Server Queue' } DefaultDisplayModel { ControllerIconModel } IconFile { '&lt;res&gt;/images/Controller-24.png' } DefaultSize { 0.5 0.5 0.5 m }\nRadiologyControlUnit JavaClass { labs.RadiologyControlUnit }  Palette { 'Custom Logic' } DefaultDisplayModel { AssembleIconModel } IconFile { '&lt;res&gt;/images/Assemble-24.png' } DefaultSize { 0.5 0.5 0.5 m }\n\nOnce you have updated the sim_custom.inc file, restart Jaamsim. If everything is working correctly the RadiologyControlUnit object should now be available under the Custom Logic palette as shown in the screenshot below:\n\n\n\n\n\n\nFigure 7.7: Screenshot of Control Unit Object\n\n\n\nOnce you have the new RadiologyControlUnit object available open your simulation and create one.\nWe now need to add the Java code to the new RadiologyControlUnit class to run the control policies. First add the following imports under the package declaration. Note These code snippets for this lab are provided in a separate file for you here XXX.\npackage labs;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport hccm.activities.ProcessActivity;\nimport hccm.controlunits.ControlUnit;\nimport hccm.entities.ActiveEntity;\nThen, within the definition of the class we need to create four methods that represent the four control policies in the model. Each control policy is a public method of the class that does not return any value (is void) and takes both a list of Active Entities, and the simulation time as inputs. We will use the same names for the methods as the control policies in the conceptual model: OnStartWaitForCheckIn, OnStartWaitForScan, OnStartWaitForTaskReceptionist, and OnStartWaitForTaskCTMachine. In the first of these, OnStartWaitForCheckIn we first need to get a list of the Receptionist Entities that are currently in the ’’WaitForTaskReceptionist” activity, and we also create a comparator object that is used to sort a list of entities by when they started their current activity.\nOnce we have the list of idle receptionists we check whether it is not empty, and if it isn’t proceed to sort it, select the first one, and transition the patient and receptionist to the check in activity.\n\npublic void OnStartWaitForCheckIn(List&lt;ActiveEntity&gt; ents, double simTime) {\n        \n    ArrayList&lt;ActiveEntity&gt; idleReceps = this.getEntitiesInActivity(\"ReceptionistEntity\", \"WaitForTaskReceptionist\", simTime);\n    ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n    if (idleReceps.size() &gt; 0) {\n      Collections.sort(idleReceps, actSartComp);\n      \n      ActiveEntity patient = ents.get(0);\n      ActiveEntity receptionist = idleReceps.get(0);\n      \n      transitionTo(\"CheckIn\", patient, receptionist);\n    }\n  }\n\nSimilar methods are defined for the other control policies, with small changes based on the types of entities that are being checked, and the activity that is started. There are gaps that need to be filled in on lines 3, 24, and 42. In the first gap you need to create an array that contains all of the CT Machines that are currently idle. In the second, you need to select which of the patients that are currently waiting should do check in with the receptionist. In the third, you need to start the next activity with the patient and CT Machine. All of these have similar lines in the first method that you can use as a guide.\n\npublic void OnStartWaitForScan(List&lt;ActiveEntity&gt; ents, double simTime) {\n  \n    // A //\n    ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n    if (idleCTs.size() &gt; 0) {\n      Collections.sort(idleCTs, actSartComp);\n      \n      ActiveEntity patient = ents.get(0);\n      ActiveEntity ct = idleCTs.get(0);\n\n      transitionTo(\"Scan\", patient, ct);\n    }\n  }\n    \npublic void OnStartWaitForTaskReceptionist(List&lt;ActiveEntity&gt; ents, double simTime) {\n      \n  ArrayList&lt;ActiveEntity&gt; waitPats = this.getEntitiesInActivity(\"PatientEntity\", \"WaitForCheckIn\", simTime);\n  ActivityStartCompare actSartComp = this.new ActivityStartCompare();\n  \n  if (waitPats.size() &gt; 0) {\n    Collections.sort(waitPats, actSartComp);\n    \n    // B //\n    ActiveEntity receptionist = ents.get(0);\n\n    transitionTo(\"CheckIn\", patient, receptionist);\n  }\n}\n\npublic void OnStartWaitForTaskCTMachine(List&lt;ActiveEntity&gt; ents, double simTime) {\n  \n  ArrayList&lt;ActiveEntity&gt; waitPats = this.getEntitiesInActivity(\"PatientEntity\", \"WaitForScan\", simTime);\n  ActivityStartCompare actSartComp = this.new ActivityStartCompare();        \n    \n  if (waitPats.size() &gt; 0) {\n    Collections.sort(waitPats, actSartComp);\n    \n    ActiveEntity patient = waitPats.get(0);\n    ActiveEntity ct = ents.get(0);\n\n    // C //\n  }\n}\n\nThe final step needed to get this logic into the simulation is to define Triggers that initiate these methods and where/when they should be called. To do this create four Trigger objects, called StartWaitCheckIn, StartWaitScan, StartWaitTaskReceptionist, and StartWaitTaskCTMachine from the HCCM palette and set the ControlUnit and ControlPolicy for each one. The value of the ControlPolicy keyword needs to exactly match the name of the method you have defined in the java code.\n\n\n\nTable 7.7: Trigger Parameters\n\n\n\n\n\nObject\nTab\nKeyword\nValue\n\n\n\n\nStartWaitCheckIn\nHCCM\nControlUnit\nRadiologyControlUnit1\n\n\nStartWaitCheckIn\nHCCM\nControlPolicy\nOnStartWaitForCheckIn\n\n\n\n\n\n\n\n\nStartWaitScan\nHCCM\nControlUnit\nRadiologyControlUnit1\n\n\nStartWaitScan\nHCCM\nControlPolicy\nOnStartWaitForScan\n\n\n\n\n\n\n\n\nStartWaitTaskReceptionist\nHCCM\nControlUnit\nRadiologyControlUnit1\n\n\nStartWaitTaskReceptionist\nHCCM\nControlPolicy\nOnStartWaitForTaskReceptionist\n\n\n\n\n\n\n\n\nStartWaitTaskCTMachine\nHCCM\nControlUnit\nRadiologyControlUnit1\n\n\nStartWaitTaskCTMachine\nHCCM\nControlPolicy\nOnStartWaitForTaskCTMachine\n\n\n\n\n\n\nThen update the parameters in the Wait Activities that these control policies should be triggered in:\n\n\n\nTable 7.8: Wait Activity Parameters\n\n\n\n\n\nObject\nTab\nKeyword\nValue\n\n\n\n\nWaitForCheckIn\nHCCM\nStartTriggerList\nStartWaitCheckIn\n\n\nWaitForCheckIn\nHCCM\nStartTriggerChoice\n1\n\n\n\n\n\n\n\n\nWaitForScan\nHCCM\nStartTriggerList\nStartWaitScan\n\n\nWaitForScan\nHCCM\nStartTriggerChoice\n1\n\n\n\n\n\n\n\n\nWaitForTaskReceptionist\nHCCM\nStartTriggerList\nStartWaitTaskReceptionist\n\n\nWaitForTaskReceptionist\nHCCM\nStartTriggerChoice\n1\n\n\n\n\n\n\n\n\nWaitForTaskCTMachine\nHCCM\nStartTriggerList\nStartWaitTaskCTMachine\n\n\nWaitForTaskCTMachine\nHCCM\nStartTriggerChoice\n1\n\n\n\n\n\n\nNow if you save and run your simulation you should be able to see patients arriving, checking in, being scanned, and leaving. If you get an error saying that a method cannot be found on the control unit, first make sure that all of the ControlPolicy inputs exactly match the names of the methods in the control unit java file. Then try closing Jaamsim, cleaning your project, and restarting Jaamsim.",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1/clinic_1.html#model-output",
    "href": "chapters/clinic_1/clinic_1.html#model-output",
    "title": "7  Radiology Clinic",
    "section": "7.4 Model Output",
    "text": "7.4 Model Output\nTo perform different experiments and multiple replications we make use of Jaamsim’s MultipleRuns feature which can be found in the Simulation object at the top of the Object Selector window. Here we can use the NumberOfReplications to control how many replications are performed. We want to do 50 replications so we set NumberOfReplications to 50. We want each replication to run for one week, so we set RunDuration to 7d. To record outputs we can make use of the Simulation object’s RunOutputList, which saves the final value of outputs at the end of each run. The scenario number, and the replication number are saved by default (by default PrintRunLabels and PrintReplications are TRUE), but we will calculate confidence intervals ourselves so we set PrintConfidenceIntervals to FALSE. Because ActiveEntities are removed from the simulation when they enter a LeaveEvent, we cannot get the total time that each patient spends in the clinic at the end of the run. This is why we created a Statistics object called TimeInSystem that records how long they have been in the system before they are destroyed. We can use the SampleAverage output of the TimeInSystem object in the Simulation’s RunOutputList to output the mean time in system for each replication. Note The SampleAverage is divided by 1[h] to give a raw number in hours for later processing in Python. Otherwise JaamSim writes an h to the data file.\n\n\n\nTable 7.9: Simulation Parameters\n\n\n\n\n\nObject\nTab\nKeyword\nValue\n\n\n\n\nSimulation\nKey Inputs\nRunDuration\n7 d\n\n\nSimulation\nKey Inputs\nRunOutputList\n{‘[TimeInSystem].SampleAverage / 1[h]’}\n\n\nSimulation\nMultiple Runs\nNumberOfReplications\n50\n\n\nSimulation\nMultiple Runs\nPrintConfidenceIntervals\nFALSE\n\n\n\n\n\n\nNow if you save and run your simulation a file should be created called ‘yourSimulationName.dat’. To speed up running the simulation you can turn off the option ‘Real time’, in the top left corner next to the play button.\nWith the model complete and the results recorded we can use Python to analyse them. First download the Python analysis file provided, then change name of the .dat file to match yours and make sure it is in the same directory as the Python file, then run the Python file. The following output should be printed:\n\n\n\n   Scenario  Replication  TimeInSystem\n0         1          1.0      0.443924\n1         1          2.0      0.521371\n2         1          3.0      0.441290\n3         1          4.0      0.418234\n4         1          5.0      0.519311\nMean             0.449299\nCI Half Width    0.007243\nName: TimeInSystem, dtype: float64",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1/clinic_1.html#task",
    "href": "chapters/clinic_1/clinic_1.html#task",
    "title": "7  Radiology Clinic",
    "section": "7.5 Task",
    "text": "7.5 Task\nConstruct a 95% confidence interval for the average utilisation of the three CT machines in each experiment. You will need to add an entry to the RunOutputList. You should get the following output:\n\n\n\nMean             0.730582\nCI Half Width    0.006098\nName: Utilisation, dtype: float64\n\n\n\nHint: there are many ways to do this. Have a look at the outputs provided on the wait activity WaitForTaskCTMachine, can you calculate the total time that the three CTMachines have spent waiting using these outputs?",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_2/clinic_2.html",
    "href": "chapters/clinic_2/clinic_2.html",
    "title": "8  Extended Radiology Clinic",
    "section": "",
    "text": "8.1 Experiments\nIn this lab we will perform one experiment with 50 replications each 1 week long. We will use the same distributions for the interarrival time, check in time, and scan duration for appointment patients as in the previous lab. The proportion of each type of patient in each priority group is given in Table 8.1:",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extended Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_2/clinic_2.html#experiments",
    "href": "chapters/clinic_2/clinic_2.html#experiments",
    "title": "8  Extended Radiology Clinic",
    "section": "",
    "text": "Table 8.1: Patient Priority Proportions\n\n\n\n\n\n\nPriority\nProportion\n\n\n\n\n1\n0.05\n\n\n2\n0.2\n\n\n3\n0.15\n\n\n4\n0.4\n\n\n5\n0.2",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extended Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_2/clinic_2.html#jaamsim-model",
    "href": "chapters/clinic_2/clinic_2.html#jaamsim-model",
    "title": "8  Extended Radiology Clinic",
    "section": "8.2 Jaamsim Model",
    "text": "8.2 Jaamsim Model\nTo model the priorities, priority order, and maintenance we need to add some components to the model from the previous lab, so create a new folder called RC2 and copy your .cfg file (and the .png files so that the graphics work) from the previous lab folder into this folder and rename it to radiology_lab_extended.cfg. First we need to add a priority attribute to the Patient entity. We can do this under the Options tab on the PatientEntity using the AttributeDefinitionList. Table Table 8.2 shows how to create the priority attribute and make the default value 0.\n\n\n\nTable 8.2: Priority Attribute\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPatientEntity\nAttributeDefinitionList\n{ priority 0 }\n\n\n\n\n\n\nNext we need a distribution to model the probabilities of the priorities. We use a DiscreteDistribution object as this allows us to define a list of values and the probability of each value occuring. Create a DiscreteDistribution object called PriorityDistribution with the values shown in Table 8.3.\n\n\n\nTable 8.3: Priority Distribution\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPriorityDistribution\nUnitType\nDimensionlessUnit\n\n\n\nRandomSeed\n4\n\n\n\nValueList\n1 2 3 4 5\n\n\n\nProbabilityList\n0.05 0.2 0.15 0.4 0.2\n\n\n\n\n\n\nSo far we have created the priority attribute and distribution, but we need to assign values from the distribution to the patient entities. With the HCCM objects we can assign attributes in the same object that create the arrival.\n\n\n\nTable 8.4: Assign Priority\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPatientArrival\nAssignmentList\n{ ‘this.obj.priority\n\n\n\n\n= [PriorityDistribution].Value’ }\n\n\n\n\n\n\nNow that we have the priority attribute we can use it change the path of the patients. We can use a Branch object (under Process Flow palette) to send the patients to different places based on the priorty attribute: those with priority 1 and 2 should go straight to the scan queue, while those with priorities 3, 4, and 5 go to wait for check in.\n\n\n\nTable 8.5: Priority Branch\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPriorityBranch\nNextComponentList\nWaitForScan WaitForCheckIn\n\n\n\nChoice\n‘this.obj.priority \\(\\leq\\) 2 ? 1 : 2’\n\n\n\n\n\n\nWe also need to update the routing from the Arrival object so that the patients go from the Arrive to the Branch.\n\n\n\nTable 8.6: Update Routing\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPatientArrival\nNextAEJObject\nPriorityBranch\n\n\n\n\n\n\nNow we need to add the new Maintenance activity, and RequireMaintenance event. We need an additional event as well as the activity because we do not want to interrupt a scan with maintenance, if the machine is currently in use when the 8 hour time is reached. This means we cannot simply schedule another maintenance activity 8 hours after the last one was scheduled, as the machine might be in use at this time. Instead, we schedule an event (called a logic event in Jaamsim) in 8 hours time, the event then triggers some logic which checks to see if the machine is free and can start maintenance, and if not changes an attribute so that it will start maintenance the next time it is free. We therefore also need to add an attribute on the CTMachineEntity called NeedMaintenance, which defaults to 0 and we will set to 1 when it has been 8 hours since the last maintenance.\nFor the maintenance activity create a process activity with a duration of 30 minutes with the CTMachineEntity as the only participant and the next activity is WaitForTaskCTMachine. Also use the start assignment list to set the value of the NeedMaintenance attribute to 0.\nThen create a logic event called RequireMaintenance and for now just use the assignment list to set the NeedMaintenance attribute to 1.\nNow we will add the new logic before connecting it with new triggers. Follow the same instructions as in the previous lab to create a new class called RadiologyExtendedControlUnit in the labs package, and copy the java code from the RadiologyControlUnit to the new RadiologyExtendedControlUnit. Add the relevant lines to the sim_custom.inc file so that it is available in the HCCM palette. Then replace the RadiologyControlUnit with a RadiologyExtendedControlUnit, and replace the references to the RadiologyControlUnit with RadiologyExtendedControlUnit in the trigger objects: StartWaitCheckIn, StartWaitScan, StartWaitTaskReceptionist, and StartWaitTaskCTMachine.\nIn the new class we need to first update the OnStartWaitForTaskCTMachine, to include the logic for having maintenance and prioritising patients, and add two new ones for the logic triggered when a CTMachine arrives, and when the RequireMaintenance event occurs. Note that we don’t need to update the OnStartWaitForScan logic as this will only start a scan if the patient is the only one waiting, so the priority does not matter.\nFirst update the OnStartWaitTaskCTMachine code as follows, note that on line 4 a comparator is created to compare patients by their priority attribute. This is then used on line 14 to sort the patients by priority. Also line 7 used the getNumAttribute function to access the value of the NeedMaintenance attribute of the CT Machine. You will need to fill in the parts labelled A, B, and C. In A the CT Machine should transition to the maintenance activity as it needs maintenance and has just become free. In B we want to save the priority of the highest priority patient that is waiting. In C we want to get the priority of the current patient in the loop, to see if it is the same as the highest priority waiting.\n\npublic void OnStartWaitForTaskCTMachine(List&lt;ActiveEntity&gt; ents, double simTime) {\n    \n  ArrayList&lt;ActiveEntity&gt; waitPats = this.getEntitiesInActivity(\"PatientEntity\", \"WaitForScan\", simTime);\n  AttributeCompare priorityComp = new AttributeCompare(\"priority\");\n  ActivityStartCompare actStartComp = this.new ActivityStartCompare();        \n  ActiveEntity ct = ents.get(0);\n  int reqMaintenance = (int) getNumAttribute(ct, \"NeedMaintenance\", simTime, -1);\n  \n  if (reqMaintenance == 1) {\n    // A //\n  }\n    \n  else if (waitPats.size() &gt; 0) {\n    Collections.sort(waitPats, priorityComp);\n    \n    int highestPriority = // B //\n    \n    ArrayList&lt;ActiveEntity&gt; priorityPatients = new ArrayList&lt;ActiveEntity&gt;();\n    for (ActiveEntity wP : waitPats) {\n      int patPri = // C //\n      if (patPri == highestPriority) {\n        priorityPatients.add(wP);\n      }\n    }\n    \n    Collections.sort(priorityPatients, actStartComp);\n    ActiveEntity patient = priorityPatients.get(0);\n              \n    transitionTo(\"Scan\", patient, ct);\n  }\n}\n\n\nThen create two new methods called OnCTArrival and OnRequireMaintenance:\n\npublic void OnCTArrival(List&lt;ActiveEntity&gt; ents, double simTime) {\n        \n  double maintenanceTimeGap = 8 * 60 * 60;\n  LogicEvent le = (LogicEvent) getSubmodelEntity(\"RequireMaintenance\");\n  \n  le.scheduleEvent(ents, maintenanceTimeGap);\n}\n  \npublic void OnRequireMaintenance(List&lt;ActiveEntity&gt; ents, double simTime) {\n      \n  double maintenanceTimeGap = 8 * 60 * 60;\n  LogicEvent le = (LogicEvent) getSubmodelEntity(\"RequireMaintenance\");\n  \n  le.scheduleEvent(ents, simTime + maintenanceTimeGap);\n  \n  ActiveEntity ct = ents.get(0);\n  if (ct.getCurrentActivity(simTime).equals(\"WaitForTaskCTMachine\")) {\n    transitionTo(\"Maintenance\", ct);\n  }      \n}\n\nTo get the new logic used in the simulation we need to add two new triggers: StartCTArrival, and StartRequireMaintenance. Set the control unit for both the triggers to be the RadiologyExtendedControlUnit, and make the control policies the respective methods in the java code. Then update the TriggerList and TriggerChoice on both the CTMachineArrival and RequireMaintenance to refer to these triggers.\nIn the previous lab we looked at the mean time that patients spend in the clinic, and we were able to output this by first using a Statistics object to calculate it and then setting it in the Simulation object’s RunOutputList. In this instance we are interested in the 90th percentile of time that patients spend in the clinic. Unfortunately the Statistics object does not provide the 90th percentile as an output. Therefore we need to capture each of the individual times that each patient spends in the clinic and calculate the 90th percentile ourselves. We can do this using an EntityLogger object from the Process Flow palette; create one and place it between the TimeInSystem object and the PatientExit, and name it PatientLogger. We then need to update the routing so that patients go through the PatientLogger object before leaving, and tell the PatientLogger object which values to record as shown in Table 8.7, note that TotalTime is an output on the entity which stores the total time that the entity has been in the simulation for:\n\n\n\nTable 8.7: Collecting Statistics\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nTimeInSystem\nNextComponent\nPatientLogger\n\n\nPatientLogger\nDataSource\n{ [Simulation].ReplicationNumber }\n\n\n\n\n{ ‘this.obj.TotalTime / 1[h]’ }\n\n\n\nNextComponent\nPatientLeave\n\n\n\n\n\n\nNow if you save and run your simulation you should be able to see the CT Machines performing maintenance every 8 hours.\nThe simulation object should be configured correctly from the previous lab so we don’t need to update it. Now if you save and run your simulation a file should be created called radiology_lab_extended.dat.\nWith the model complete and the results recorded we can use Python to analyse them. First download the Python analysis file provided, change the name of the .log file to match yours, and make sure it is in the same directory as the Python file, then run the Python file. The following table should be printed:\n\n\n\n               TimeInSystem\nMean               0.893513\nCI_Half_Width      0.028886",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extended Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_2/clinic_2.html#task",
    "href": "chapters/clinic_2/clinic_2.html#task",
    "title": "8  Extended Radiology Clinic",
    "section": "8.3 Task",
    "text": "8.3 Task\nBy also saving the priority of the patients in the patient logger, construct 95% confidence intervals for the 90th percentile of the time spent in the clinic for each priority group. You should get the following output:\n\n\n\n              Mean  CI_Half_Width\nPriority                         \n1.0       0.481123       0.011888\n2.0       0.501677       0.006659\n3.0       0.649709       0.013620\n4.0       0.886900       0.023870\n5.0       1.755913       0.128359",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Extended Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_3/clinic_3.html",
    "href": "chapters/clinic_3/clinic_3.html",
    "title": "9  Using Traces and Scenarios",
    "section": "",
    "text": "9.1 Jaamsim Model\nTo run the simulation from a data trace we need to make some changes to the Jaamsim model. Once again create a new folder called RC3 and copy your .cfg file (and the .png files so that the graphics work) from the previous lab folder into this folder and rename it to radiology_lab_trace.cfg. First, download the RC_50_week_data.txt file from Canvas. This file contains 50 weeks of data of patients at the radiology clinic including: the time the patient arrived, the priority of the patient, the time the patient took to check in, and the time the patient took to have their scan.\nBefore we load the data in we will first change the starting date of the simulation, which defaults to 1970, to instead be 2024, so that the data read from the file is interpreted correctly. To do this go to the Simulation object and under the Options tab enter 2024-01-01 for the StartDate.\nTo use the data in Jaamsim we use a FileToMatrix object found in the Basic Objects palette. Create a FileToMatrixObject, rename it PatientData, and select the RC_50_-week_data.txt file as the DataFile.\nWe can now access the data in the file by using the Value output of the PatientData object. The first place we will use this data is in the PatientArrival object, so that patients arrive according to the data in the file, rather than the distribution used previously. We first create two CustomOutputs (under the options tab) on the PatientArrival object to make accessing the data easier. CustomOutputs are similar to attributes but they can be expressions (formulas) and are re-calculated at each time step in the simulation. The two outputs we create will correspond to the data for the patient that has just arrived (thisPatientData) and the patient that is going to arrive next (nextPatientData). We need both of these so that we can calculate the appropriate interarrival time between the patients.\nOnce we have created these outputs we use them in the InterArrivalTime, and AssignmentList of the PatientArrival.\nNote that in the AssignmentList we are assigning values from the data file to attributes on the patient entity for priority, check in time, and scan time. We will use these attributes later to determine how long those activities take (the priority attribute is already used in the PriorityBranch).\nTo avoid getting an error these attributes need to be added to the PatientEntity object. So update the AttributeDefinitionList of the PatientEntity to include checkInTime and scanTime as well as the current priority, all with a default of 0.\nWe now need to use the checkInTime and scanTime attributes to determine how long the check ins and scans take. Set the Duration of the CheckIn activity to this.CurrentParti-cipants(1).checkInTime * 1[min]. this.CurrentParticipants refers to the group of entities that have just started the activity (for check in this is a patient and a receptionist), and we use the index 1 as the patient comes first, then we access the checkInTime attribute. We then need to multiply this by 1[min] to convert the number into a time, and use minutes as the attribute is in minutes.\nSimilarly for the Scan activity set the Duration to this.CurrentParticipants(1).scanTime * 1[h], note that here we use 1[h] as the attribute is in hours.\nNow, suppose we are interested in the time that patients spend waiting for check in and for the scan. We can’t use the current PatientLogger as it only records the total time that patients are in the system for. We could add attributes for each time that we are interested in, and assign the value when the entity gets to the relevant stage, and then use the PatientLogger to log these attributes. We can instead use an EventLogger from the HCCM palette. The EventLogger records the time that an entity starts each of the activities that it participates in. So, create an EventLogger and call it PatientEventLogger.\nThen, to get the events recorded go to the PatientLeave object and under the HCCM tab enter PatientEventLogger for the EventLogger keyword. Now any entities that are sent to the patient leave will have the start times of any activities that they participated in recorded.\nWe will now configure the Simulation object to run one long replication for several scenarios. Under the Key Inputs tab enter 50w for the RunDuration, this will make the simulation run for 50 weeks. We have to run one 50 week replication rather than 50 one week replications as Jaamsim cannot read in a new file when each replication starts.\nWe want to try out four scenarios with either three or four CT machines, and either one or two receptionists. As there are two factors we are changing we use a ScenarioIndex with two numbers, the first indexes the scenarios relating to the number of CT Machines, and the second those related to the number of receptionists.\nSince there are two options for the first index and two for the second we enter 2 2 for the ScenarioIndexDefinitionList under the MultipleRuns tab of the Simulation object. We will start from scenario 1 and end at scenario 2 in both the indices so StartingScenarioNumber is 1-1 and EndingScenarioNumber is 2-2. We are going to run just one long replication for each scenario so set the NumberOfReplications to 1.\nNow Jaamsim will run 4 scenarios, but we need to make it so that the number of CT Machines and Receptionists actually changes in each of the scenarios. For the CT Machines we set the MaxNumber on the CTMachineArrival to [Simulation].ScenarioIndex(1) + 2, which gets the value of the first scenario index and adds 2 to it. For the Receptionists we can set the MaxNumber on the ReceptionistArrival to [Simulation].ScenarioIndex(2), in this case we don’t need to add one as the scenario index is the same as the number of receptionists we want to use.\nDownload and run the RadiologyLabTraceAnalysis.R file, you will have to update the directory that it reads the data from and the name of the data file used. The script splits each replication into 50 batches, each one week long, and calculates the mean across the batches and the four scenarios of the 90th percentile waiting time for both check in and scan within each of batch. No warm-up period is used, so this assumes that being empty and idle is a typical state of the system. Splitting into batches by week assumes that each week is not correlated to the preceding and following weeks. You should get the following output:",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Using Traces and Scenarios</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_3/clinic_3.html#jaamsim-model",
    "href": "chapters/clinic_3/clinic_3.html#jaamsim-model",
    "title": "9  Using Traces and Scenarios",
    "section": "",
    "text": "Table 9.1: Update PatientArrival\n\n\n\n\n\nObject\nKeyword\nValue\n\n\n\n\nPatientArrival\nCustomOutputList\n{ thisPatientData ‘[PatientData].Value(this.NumberAdded + 1)’ }\n\n\n\n\n{ nextPatientData ‘[PatientData].Value(this.NumberAdded + 2)’ }\n\n\n\nFirstArrivalTime\n[PatientData].Value(2)(2)\n\n\n\nInterArrivalTime\n‘this.nextPatientData(2) - this.thisPatientData(2)’\n\n\n\nAssignmentList\n{ ‘this.obj.priority= this.thisPatientData(3)’ }\n\n\n\n\n{ ‘this.obj.checkInTime= this.thisPatientData(4)’ }\n\n\n\n\n{ ‘this.obj.scanTime= this.thisPatientData(5)’ }",
    "crumbs": [
      "Jaamsim Labs",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Using Traces and Scenarios</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1_cm/clinic_1_cm.html",
    "href": "chapters/clinic_1_cm/clinic_1_cm.html",
    "title": "10  Radiology Clinic",
    "section": "",
    "text": "10.1 Data",
    "crumbs": [
      "Conceptual Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1_cm/clinic_1_cm.html#data",
    "href": "chapters/clinic_1_cm/clinic_1_cm.html#data",
    "title": "10  Radiology Clinic",
    "section": "",
    "text": "Table 10.1: List of Global Variables\n\n\n\n\n\nName\nDescription\nInitial Value\n\n\n\n\nNextPatIdNum\nThe Id number that will be assigned to the next patient\n1\n\n\nNextReceptionistIdNum\nThe Id number that will be assigned to the next receptionist\n1\n\n\nNextCTMachineIdNum\nThe Id number that will be assigned to the next CT Machine\n1\n\n\n\\(P\\)\nThe set of all patients\n\\(\\emptyset\\)\n\n\n\\(R\\)\nThe set of all receptionists\n\\(\\emptyset\\)\n\n\n\\(C\\)\nThe set of all CT Machines\n\\(\\emptyset\\)\n\n\n\n\n\n\n\n\n\nTable 10.2: List of Data Modules\n\n\n\n\n\nName\nSource\nIdentification\nInput\nOutput\n\n\n\n\nPatientInterarrivalTime\nPoisson Process\nParameter\nMean interarrival time\nSample from Distribution\n\n\nNumReceptionists\nConstant\nParameter\nN/A\nValue\n\n\nNumCTMachines\nConstant\nParameter\nN/A\nValue\n\n\nCheckInTime\nUniform Distribution\nParameter\nMin and max time\nSample from Distribution\n\n\nScanTime\nLog-normal Distribution\nParameter\nMean and std. dev.\nSample from Distribution",
    "crumbs": [
      "Conceptual Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1_cm/clinic_1_cm.html#components",
    "href": "chapters/clinic_1_cm/clinic_1_cm.html#components",
    "title": "10  Radiology Clinic",
    "section": "10.2 Components",
    "text": "10.2 Components\n\n\n\nTable 10.3: List of Entities\n\n\n\n\n\nEntity\nAttributes\n\n\n\n\nPatient\nID\n\n\n\nState\n\n\n\nStateTimes\n\n\n\n\n\n\nReceptionist\nID\n\n\n\nState\n\n\n\nStateTimes\n\n\n\n\n\n\nCT Machine\nID\n\n\n\nState\n\n\n\nStateTimes\n\n\n\n\n\n\n\n\n\nTable 10.4: List of Transitions\n\n\n\n\n\nNo.\nParticipant\nFrom Event\nTo Event\n\n\n\n\n1\nPatient\nArrive(P)\nWait for check in.Start\n\n\n2\nPatient\nWait for check in.End\nCheck in.Start\n\n\n3\nPatient\nCheck in.End\nWait for scan.Start\n\n\n4\nPatient\nWait for scan.End\nScan.Start\n\n\n5\nPatient\nScan.End\nLeave(P)\n\n\n6\nReceptionist\nArrive(R)\nWait for task(R).Start\n\n\n7\nReceptionist\nWait for task(R).End\nCheck in.Start\n\n\n8\nReceptionist\nCheck in.End\nWait for task(R).Start\n\n\n9\nReceptionist\nWait for task(R).End\nLeave(R)\n\n\n10\nCT Machine\nArrive(CT)\nWait for task(CT).Start\n\n\n11\nCT Machine\nWait for task(CT).End\nScan.Start\n\n\n12\nCT Machine\nScan.End\nWait for task(CT).Start\n\n\n13\nCT Machine\nWait for task(CT).End\nLeave(CT)\n\n\n\n\n\n\n\n\n\nTable 10.5: Activities\n\n\n\n\n\n\nActivity\nParticipants\nEvent\nType\nState Change\n\n\n\n\nWait for Check In\nPatient (p)\nStart\nScheduled\nTRIGGER OnStartWaitForCheckIn WITH p\n\n\n\n\nEnd\nControlled\n\n\n\nCheck In\nPatient (p), Receptionist (r)\nStart\nControlled\nSCHEDULE Check In.End at TIME + CheckInTime()\n\n\n\n\nEnd\nScheduled\nSTART Wait for Scan WITH p\nSTART Wait for Task (R) WITH r\n\n\nWait for Scan\nPatient (p)\nStart\nScheduled\n\n\n\n\n\nEnd\nControlled\nTRIGGER OnStartWaitForScan WITH p\n\n\nScan\nPatient (p), CTMachine (c)\nStart\nControlled\nSCHEDULE Scan.End at TIME + ScanTime()\n\n\n\n\nEnd\nScheduled\nSTART Leave (P) WITH p\nSTART Wait for Task (CT) WITH c\n\n\nWait for Task (R)\nReceptionist (r)\nStart\nScheduled\nTRIGGER OnStartWaitForTaskR WITH r\n\n\n\n\nEnd\nControlled\n\n\n\nWait for Task (CT)\nCTMachine (c)\nStart\nScheduled\nTRIGGER OnStartWaitForTaskCT WITH c\n\n\n\n\nEnd\nControlled\n\n\n\n\n\n\n\n\n\n\n\nTable 10.6: Events\n\n\n\n\n\n\nEvent\nParticipants\nType\nState Change\n\n\n\n\nSimulation Start\n-\nScheduled\nSCHEDULE Arrival (R) at TIME\nSCHEDULE Arrival (CT) at TIME\nSCHEDULE Arrival (P) at TIME + PatientInterArrival()\n\n\nArrival (P)\nPatient (p)\nScheduled\np.ID = NextPatIDNum\np.Priority = PatientPriority()\nNextPatIDNum = NextPatIDNum + 1\nSCHEDULE Arrival (P) at TIME + PatientInterArrival()\nSTART Wait for Check In WITH p\n\n\nLeave (P)\nPatient (p)\nScheduled\nCalculate statistics for p\n\n\nArrival (R)\nReceptionist (r)\nScheduled\nr.ID = NextReceptionistIDNum\nNextReceptionistIDNum = NextReceptionistIDNum + 1\nIF NextReceptionistIDNum &lt;= NumReceptionists THEN\n    SCHEDULE Arrival (R) at TIME\nEND IF\nSTART Wait for Task (R) WITH r\n\n\nLeave (R)\nReceptionist (r)\nScheduled\nCalculate statistics for r\n\n\nArrival (CT)\nCTMachine (c)\nScheduled\nc.ID = NextCTMachineIDNum\nNextCTMachineIDNum = NextCTMachineIDNum + 1\nIF NextCTMachineIDNum &lt;= NumCTMachines THEN\n    SCHEDULE Arrival (CT) at TIME\nEND IF\nSTART Wait for Task (CT) WITH c\n\n\nLeave (P)\nCTMachine (c)\nScheduled\nCalculate statistics for c",
    "crumbs": [
      "Conceptual Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1_cm/clinic_1_cm.html#activity-diagrams",
    "href": "chapters/clinic_1_cm/clinic_1_cm.html#activity-diagrams",
    "title": "10  Radiology Clinic",
    "section": "10.3 Activity Diagrams",
    "text": "10.3 Activity Diagrams\n\n\n\n\n\n\nFigure 10.1: Patient Activity Diagram\n\n\n\n\n\n\n\n\n\nFigure 10.2: Receptionist Activity Diagram\n\n\n\n\n\n\n\n\n\nFigure 10.3: CT Activity Diagram",
    "crumbs": [
      "Conceptual Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  },
  {
    "objectID": "chapters/clinic_1_cm/clinic_1_cm.html#logic",
    "href": "chapters/clinic_1_cm/clinic_1_cm.html#logic",
    "title": "10  Radiology Clinic",
    "section": "10.4 Logic",
    "text": "10.4 Logic\n\n\n\nTable 10.7: OnStartWaitForCheckIn\n\n\n\n\n\n\nTriggered by: Patient p\n\n\n\n\n\nreceps = {r FOR r IN R IF r.State = \"Wait for task (R)\"}\nIF receps IS NOT empty THEN \n    r_hat = argmin{r.CurrentStart FOR r IN receps}\n    START Check In WITH p, r_hat\nEND IF\n\n\n\n\n\n\n\n\n\nTable 10.8: OnStartWaitForScan\n\n\n\n\n\n\nTriggered by: Patient p\n\n\n\n\n\ncts = {c FOR c IN C IF c.State = \"Wait for task (C)\"}\nIF cts IS NOT empty THEN \n    c_hat = argmin{c.CurrentStart FOR c IN cts}\n    START Scan WITH p, r_hat\nEND IF\n\n\n\n\n\n\n\n\n\nTable 10.9: OnStartWaitForTaskR\n\n\n\n\n\n\nTriggered by: Receptionist r\n\n\n\n\n\npatients = {p FOR p IN P IF p.State = \"Wait for Check In\"}\nIF patients IS NOT empty THEN \n    p_hat = argmin{p.CurrentStart FOR p IN patients}\n    START Check In WITH p, r_hat\nEND IF\n\n\n\n\n\n\n\n\n\nTable 10.10: OnStartWaitForTaskCT\n\n\n\n\n\n\nTriggered by: CTMachine c\n\n\n\n\n\npatients = {p FOR p IN P IF p.State = \"Wait for Scan\"}\nIF patients IS NOT empty THEN \n    p_hat = argmin{p.CurrentStart FOR p IN patients}\n    START Scan WITH p, r_hat\nEND IF",
    "crumbs": [
      "Conceptual Models",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Radiology Clinic</span>"
    ]
  }
]